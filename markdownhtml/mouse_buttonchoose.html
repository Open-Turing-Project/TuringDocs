<h1>Mouse.ButtonChoose</h1>

<h2>Syntax</h2>

<p><strong>Mouse.ButtonChoose</strong> (<em>choice</em> : <strong>string</strong>)</p>

<h2>Description</h2>

<p>The <strong>Mouse.ButtonChoose</strong> procedure is used to change the mode of the mouse. In Turing, the mouse can either be in "<em>single-button mode</em>" or in "<em>multi-button mode</em>". In "<em>single-button mode</em>" the mouse is treated as a one button mouse. A button is considered pressed when any button is pressed and released only when all buttons have been released.</p>

<p>In Turing, the mouse starts in "<em>single-button mode</em>".</p>

<p>The parameter <em>choice</em> can be one of "singlebutton", "onebutton" (which switch the mouse into "<em>single-button mode</em>") or "multibutton" (which switches the mouse into "<em>multi-button mode</em>").</p>

<h2>Example</h2>

<p>A program that displays the status of the mouse at the top left corner of the screen.</p>

<pre><code>    Mouse.ButtonChoose ("multibutton")
    var x, y, button, left, middle, right : int
    Mouse.Where (x, y, button)
    left := button mod 10           % left = 0 or 1
    middle := (button - left) mod 100   % middle = 0 or 10
    right := button - middle - left     % right = 0 or 100
    if left = 1 then
        put "left button down"
    end if
    if middle = 10 then
        put "middle button down"
    end if
    if right = 100 then
        put "right button down"
    end if
</code></pre>

<h2>Status</h2>

<p>Exported qualified.</p>

<p>This means that you can only call the function by calling <strong>Mouse.ButtonChoose</strong>, not by calling <strong>ButtonChoose</strong>.</p>

<h2>See also</h2>

<p><strong><a href="Mouse.ButtonMoved">mouse_buttonmoved.html</a></strong> and <strong><a href="Mouse.ButtonWait">mouse_buttonwait.html</a></strong> to get mouse events saved in a queue. See also <strong><a href="Mouse.Where">mouse_where.html</a></strong> to get the current status of mouse button(s).</p>
