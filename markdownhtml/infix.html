<h1>infix</h1>

<h2>Syntax</h2>

<p>An <em>infixOperator</em> is one of:</p>

<p>(a) <strong>+</strong>   <em>% Integer and real addition; set union;</em>
<em>% string catenation</em>
(b) -   <em>% Integer and real subtraction; set difference</em>
(c) <strong>*</strong>   <em>% Integer and real multiplication; set intersection</em>
(d) <strong>/</strong>   <em>% Real division</em>
(e) <strong>div</strong>   <em>% Truncating integer division</em>
(f) <strong>mod</strong>   <em>% Modulo</em>
(g) <strong>rem</strong>   <em>% Remainder</em>
(h) <strong><strong><strong>   <em>% Integer and real exponentiation</em>
(i) </strong>&lt;</strong>   <em>% Less than</em>
(j) </strong>><strong>   <em>% Greater than</em>
(k) =   <em>% Equal</em>
(l) </strong>&lt;<strong>=   <em>% Less than or equal; subset</em>
(m) </strong>><strong>=   <em>% Greater than or equal; superset</em>
(n) </strong>not=<strong>   <em>% Not equal</em>
(o) </strong>and<strong>   <em>% And (boolean conjunction)</em>
(p) </strong>or<strong>   <em>% Or (boolean disjunction)</em>
(q) =</strong>><strong>   <em>% Boolean implication</em>
(r) </strong>in<strong>   <em>% Member of set</em>
(s) </strong>not<strong> </strong>in<strong>   <em>% Not member of set</em>
(t) </strong>shr<strong>   <em>% Shift right</em>
(u) </strong>shl<strong>   <em>% Shift left</em>
(v) </strong>xor**   <em>% Exclusive OR</em></p>

<h2>Description</h2>

<p>An <em>infix operator</em> is placed between two values or <em>operands</em> to produce a third value. For example, the result of 5 + 7 is 12. In some cases the meaning of the operator is determined by its operands. For example, in "pine" + "apple", the + operator means string catenation while in 5 + 7 it means integer addition. There are also <em>prefix operators</em> (-, + and <strong>not</strong>), which are placed in front of a single value. See <em>prefix operator</em>.</p>

<p>In expressions with several operators, such as 3 + 4 * 5, the <em>precedence</em> rules determine the order in which the operation is done  (see <em>precedence</em> for a listing of these rules). In this example, the multiplication is done before the addition, so the expression is equivalent to 3 + (4 * 5).</p>

<p>The numerical (integer or real) operators are +, -, *, /, <strong>div</strong>, <strong>mod</strong>, and <strong>. All of these except </strong>div<strong> produce a </strong>real<strong> result when at least one of their operands is </strong>real<strong>. If both operands are integers, the result is an integer except in the case of </strong>real<strong> division (/) which always produces a </strong>real** result regardless of the operands.</p>

<p>The <strong>div</strong> operator is like <strong>real</strong> division (<strong>/</strong>), except that it always produces an integer result, truncating any fraction to produce the nearest integer in the direction of zero.</p>

<p>The <strong>mod</strong> operator is the <em>modulo</em> and the <strong>rem</strong> operator is the <em>remainder</em>. The sign of the result of <strong>mod </strong>operator is the same as the sign of the second operand. The <strong>rem</strong> operator operates like the <strong>mod</strong> operator in Turing (and in most other languages). It produces the remainder, which is the difference between <strong>real</strong> division (<strong>/</strong>) and integer division (<strong>div</strong>). When both operands are positive, this is the <em>modulo</em>. For example, 14 <strong>mod</strong> 10 is 4. If one of the operands is negative, a negative answer may result, for example, 7 <strong>mod</strong> 2 is 1. See also the <strong>int</strong> and <strong>real</strong> types.</p>

<p>The comparison operators (&lt;, >, =, &lt;=, >=, <strong>not=</strong>) can be applied to numbers as well as to enumerated types. They can also be applied to strings to determine the <em>ordering</em> between strings (see <strong>string</strong> type for details). Arrays, records, unions and collections cannot be compared. Boolean values (<strong>true</strong> and <strong>false</strong>) can be compared only for equality (= and <strong>not=</strong>); the same applies to <strong>pointer</strong> values. Set values can be compared using &lt;= and >=, which are the subset and superset operators. The <strong>not=</strong> operator can be written as ~=.</p>

<p>Strings are manipulated using catenation (+) as well as substring expressions (see <em>substring</em>) and the <strong>index</strong> function (see <strong>index</strong>). See also the <strong>string</strong> type.</p>

<p>The operators to combine true/false values are <strong>and</strong>, <strong>or</strong>, and => (implication), as well as equality (= and <strong>not=</strong>). See also the <strong>boolean</strong> type.</p>

<p>The set operators are union (+), intersection (*), set difference (-), subset (&lt;=), superset (>=), and membership (<strong>in</strong> and <strong>not</strong> <strong>in</strong>). See also the <strong>set</strong> type.</p>

<p>The <strong>shr</strong> (shift right), <strong>shl</strong> (shift left) and <strong>xor</strong> (exclusive OR) operators accept and produce natural numbers. See <strong>shr</strong>, <strong>shl</strong>, and <strong>xor</strong>.</p>
