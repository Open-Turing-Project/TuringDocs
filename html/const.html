<html>
<head><title>const</title></head>
<body>
<table width="100%"><tr valign="top"><td align="left"><font size="+2"><b>const</b></font></td><td align="right"><font size="+1"><b>constant declaration</b></font></td></table><p>
<table><tr valign="top"><td><b>Syntax&nbsp;&nbsp;</b></td>
<td> A <i>constantDeclaration</i> is:<p>
<table><tr valign="top"><td width="40">&nbsp;</td><td colspan="8"><font size="+1"><b>const</b> <i>id</i> [ : <i>typeSpec</i> ] := <i>initializingValue</i></td></tr>
</table><p><tr valign="top"><td><b>Description&nbsp;&nbsp;</b></td>
<td> A const declaration creates a name <i>id</i> for a value.<p>
<tr valign="top"><td><b>Example&nbsp;&nbsp;</b></td>
<td><p>
<pre><tt>        <b>const</b> <i>c </i>:= 3
        <b>const</b> <i>s </i>:= "Hello"      <i>% The type of s is string</i>
        <b>const</b> x := <i>sin </i>(<i>y)</i> ** 2
        <b>const</b> <i>a </i>: <b>array</b> 1..3 <b>of</b> <b>int</b> := <b>init</b> (1, 2, 3)
        <b>const</b> <i>b </i>: <b>array</b> 1..3 <b>of</b> <b>int</b> := <i>a</i>
        <b>const</b> <i>c </i>: <b>array</b> 1..2, 1..2 <b>of</b> <b>int</b> := <b>init</b> (1, 2, 3, 4)
                <i>% So c(1</i>,<i>1)=1</i>,<i> c(1</i>,<i>2)=2</i>,<i> c(2</i>,<i>1)=3</i>,<i> c(2</i>,<i>2)=4</i></tt></pre>
<tr valign="top"><td><b>Details&nbsp;&nbsp;</b></td>
<td> The initializing value can be an arbitrary value or else a list of items separated by commas inside <b>init</b> (…). The syntax of <i>initializingValue </i>is:<p>
<table><tr valign="top"><td width="40">&nbsp;</td><td>a.</td><td width="10">&nbsp;</td><td><i>expn</i></td></tr>
<tr valign="top"><td width="40">&nbsp;</td><td>b.</td><td width="10">&nbsp;</td><td><b>init</b> (initializingValue, initializingValue)</td></tr>
</table><p>
Each <b>init</b> (…) corresponds to an array, record or union value that is being initialized. These must be nested for initialization of nested types. In the Pascal language, constants must have values known at compile time; Turing has no such restriction.<p>
When the typeSpec is omitted, the variable's type is taken to be the (root) type of the initializing expression, for example, <b>int</b> or <b>string</b>. The typeSpec cannot be omitted for dynamic arrays or when the initializing value is of the form <b>init</b> (…). The values inside <b>init</b> (…) must be known at compile time.<p>
The keyword <b>pervasive</b> can be inserted just after <b>const</b>. When this is done, the constant is visible inside all subconstructs of the constant's scope. Without <b>pervasive</b>, the constant is not visible inside modules, monitors or classes unless explicitly imported. Pervasive constants need not be imported. You can abbreviate <b>pervasive</b> as an asterisk (<b>*</b>).<p>
You can also optionally use the <b>register</b> keyword to request that the constant be placed in a machine register. The syntax for constantDeclaration is actually:<p>
<pre><tt>        <b>const</b> [<b>pervasive</b>] [<b>register</b>] <i>id</i> [ : <i>typeSpec</i> ] := <i>initializingValue</i></tt></pre>
In the current (2002) implementation, programs are run interpretively using pseudo-code, which has no machine registers, and the <b>register</b> keyword is ignored. See also <b>register</b> for restrictions on the use of register constants.<p>
</table></body>
</html>
