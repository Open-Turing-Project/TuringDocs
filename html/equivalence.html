<html>
<head><title>equivalence</title></head>
<body>
<table width="100%"><tr valign="top"><td align="left"><font size="+2"><b>equivalence</b></font></td><td align="right"><font size="+1"><b>of types</b></font></td></table><p>
<table><tr valign="top"><td><b>Description&nbsp;&nbsp;</b></td>
<td> Two types are <i>equivalent</i> to each other if they are essentially the same types (the exact rules are given below). When a variable is passed to a <b>var</b> formal parameter, the types of the variable and the formal parameter must be equivalent because they are effectively the same variable. When an expression is assigned to a variable, their types must be equivalent, except for special cases. For example, Turing allows you to assign an integer expression to a <b>real</b> variable (see <i>assignability </i>for details).<p>
<tr valign="top"><td><b>Example&nbsp;&nbsp;</b></td>
<td><p>
<pre><tt>        <b>var</b> <i>j</i> : <b>int</b>
        
        <b>var</b> <i>b</i> : <b>array</b> 1 .. 25 <b>of</b> <b>string</b>
        
        <b>type</b> <i>personType</i> :
            <b>record</b>
                <i>age</i> : <b>int</b>
                <i>name</i> : <b>string</b> (20)
            <b>end</b> <b>record</b>
        
        <b>procedure</b> <i>p </i>(<b>var</b> <i>i</i> : <b>int</b>, <b>var</b><i> a</i> : <b>array</b> 1 .. 25 of <b>string</b>,
                    <b>var</b> <i>r</i> : <i>personType)</i>
        … <i>body of procedure p</i>,<i> which modifies each of i</i>,<i> a and r …</i>
        end<i> p</i>
        
        <b>var</b><i> s</i> : <i>personType</i>
        <i>p</i> (<i>j</i>, <i>b</i>, <i>s)</i>     <i>% Procedure call to p</i>
                    <i>% i and j have the equivalent type </i>int
                    <i>% Arrays a and b have equivalent types</i>
                    <i>% Records r and s have equivalent types</i></tt></pre>
<tr valign="top"><td><b>Details&nbsp;&nbsp;</b></td>
<td> Two types are defined to be <i>equivalent </i>if they are:<p>
<table><tr valign="top"><td>(a)</td><td width="10">&nbsp;</td><td>the same standard type (<b>int</b>, <b>real</b>, <b>boolean</b> or <b>string</b>),</td></tr>
<tr valign="top"><td>(b)</td><td width="10">&nbsp;</td><td>subranges with equal first and last values,</td></tr>
<tr valign="top"><td>(c)</td><td width="10">&nbsp;</td><td>arrays with equivalent index types and equivalent component types,</td></tr>
<tr valign="top"><td>(d)</td><td width="10">&nbsp;</td><td>strings with equal maximum lengths,</td></tr>
<tr valign="top"><td>(e)</td><td width="10">&nbsp;</td><td>sets with equivalent base types, or</td></tr>
<tr valign="top"><td>(f) </td><td width="10">&nbsp;</td><td>pointers to the same collection; in addition,</td></tr>
<tr valign="top"><td>(g)</td><td width="10">&nbsp;</td><td>a declared type identifier is also equivalent to the type it names (and to the type named by that type, if that type is a named type, etc.)</td></tr>
<tr valign="top"><td>(h)</td><td width="10">&nbsp;</td><td>both <b>char</b>,</td></tr>
<tr valign="top"><td>(i)</td><td width="10">&nbsp;</td><td>both <b>char</b>(<i>n</i>) with the same length,</td></tr>
<tr valign="top"><td>(j)</td><td width="10">&nbsp;</td><td>both procedure types, with corresponding equivalent parameter types and corresponding <b>var</b> or non-<b>var</b> of the parameters,</td></tr>
<tr valign="top"><td>(k)</td><td width="10">&nbsp;</td><td>both function types, with corresponding equivalent parameter types and corresponding <b>var</b> or non-<b>var</b> of the parameters and equivalent result types,</td></tr>
<tr valign="top"><td>(l)</td><td width="10">&nbsp;</td><td>both pointer types to the same class or equivalent type and both are checked or unchecked.</td></tr>
</table><p>
Each separate instance of a record, union or enumerated type (written out using one of the keywords <b>record</b>, <b>union</b> or <b>enum</b>) creates a distinct type, equivalent to no other type. By contrast, separate instances of arrays, strings, subranges and sets are considered equivalent if their parts are equal and equivalent.<p>
Opaque type <i>T</i>, exported from a module, monitor or class <i>M</i> as <b>opaque</b>, is a special case of equivalence. Outside of <i>M</i> this type is written <i>M</i>.<i>T</i>, and is considered to be distinct from all other types. By contrast, if type <i>U </i>is exported non-<b>opaque</b>, the usual rules of equivalence apply. The parameter or result type of an exported procedure or function or an exported constant is considered to have type <i>M</i>.<i>T</i> outside of <i>M</i> if the item is declared using the type identifier <i>T</i>. Outside of <i>M</i>, the <b>opaque</b> type can be assigned, but not compared.<p>
It is not required that subprogram types have the same names and parameter names to be equivalent. They also do not require the same factoring of parameters across their types, as in <i>i</i>,<i> j: </i><b>int</b> instead of <i>i: </i><b>int</b>,<i> j: </i><b>int</b>.<p>
</table></body>
</html>
