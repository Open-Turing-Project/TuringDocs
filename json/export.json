{
  "title": "export",
  "fileName": "export",
  "sections": [
    {
      "title": "Syntax",
      "raw_content": "An <i>exportList</i> is:<p>\r\n</p>\n<table><tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"8\"><font size=\"+1\"><b>export</b> [ <i>howExport</i> ] <i>id</i>  {, [ <i>howExport</i> ] <i>id</i> }</font></td>\n</tr></table>\n<p></p>",
      "text_content": " An exportList is:\r\n export [ howExport ] id  {, [ howExport ] id }",
      "mdown_content": "An *exportList* is:\n **export** [ *howExport* ] *id*  {, [ *howExport* ] *id* }"
    },
    {
      "title": "Description",
      "raw_content": "An <b>export</b> list is used to specify those items declared in a module, monitor or class that can be used outside of it. Items that are declared inside a module, monitor or class but not exported cannot be accessed outside of it.<p>\r\n</p>",
      "text_content": " An export list is used to specify those items declared in a module, monitor or class that can be used outside of it. Items that are declared inside a module, monitor or class but not exported cannot be accessed outside of it.\r\n",
      "mdown_content": "An **export** list is used to specify those items declared in a module, monitor or class that can be used outside of it. Items that are declared inside a module, monitor or class but not exported cannot be accessed outside of it."
    },
    {
      "title": "Example",
      "code": [
        "        module stack\r\n            export push, pop\r\n            var top : int := 0\r\n            var contents : array 1..100 of string\r\n            procedure push  end push\r\n            procedure pop  end pop\r\n        end stack\r\n        \r\n        stack . push (\"Harvey\")\r\n        var name : string\r\n        stack . pop (name)      % This sets name to Harvey"
      ],
      "raw_content": "In this example, the procedures names <i>pop</i> and <i>push</i> are exported from the <i>stack</i> module. These two procedures are called from outside the module on the last and third from last lines of the example. Notice that the word <i>stack</i> and a dot must precede the use of these names. Since <i>top </i>and <i>contents</i> were not exported, they can be accessed only from inside the module.<p>\r\n</p>",
      "text_content": " In this example, the procedures names pop and push are exported from the stack module. These two procedures are called from outside the module on the last and third from last lines of the example. Notice that the word stack and a dot must precede the use of these names. Since top and contents were not exported, they can be accessed only from inside the module.\r\n\r\n",
      "mdown_content": "In this example, the procedures names *pop* and *push* are exported from the *stack* module. These two procedures are called from outside the module on the last and third from last lines of the example. Notice that the word *stack* and a dot must precede the use of these names. Since *top *and *contents* were not exported, they can be accessed only from inside the module."
    },
    {
      "title": "Details",
      "code": [
        "        export (push, pop)"
      ],
      "raw_content": "Procedures, functions, variables, constants and types can be exported. Modules, monitors or classes canot be exported. Parentheses are allowed around the items in an export list, as in:<p>\r\n</p>\r\nThe following syntax specifies that each exported identifier can optionally be preceded by the keywords <b>var</b>, <b>unqualified</b>, <b>pervasive</b> and <b>opaque</b>. Of these, only <b>opaque</b> is available in Turing proper.<p>\r\nThe form of <i>howExport</i> is:</p>\n<p>\r\n</p>\n<table><tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td>{ <i>exportMethod</i> }</td>\n</tr></table>\n<p>\r\nThe form of <i>exportMethod</i> is one of:</p>\n<p>\r\n</p>\n<table>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td>(a)</td>\n<td width=\"10\">&nbsp;</td>\n<td><b>var</b></td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td>(b)</td>\n<td width=\"10\">&nbsp;</td>\n<td><b>unqualified</b></td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td>(c)</td>\n<td width=\"10\">&nbsp;</td>\n<td><b>pervasive</b></td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td>(d)</td>\n<td width=\"10\">&nbsp;</td>\n<td><b>opaque</b></td>\n</tr>\n</table>\n<p>\r\nThe keyword <b>var</b> means that the exported variable can be changed outside of the exporting module, monitor or class. This keyword applies only to exported variables. For example, if string variable <i>name </i>is exported <b>var</b> from module <i>M</i>,<i> name </i>can be changed from outside of <i>M</i> by <i>M.name </i>:= \"<i>Surprise!</i>\".</p>\n<p>\r\nThe keyword <b>unqualified</b> means that references to the exported item do not need to be prefixed by the name of the exporting item. For example, if module <i>M</i> exports procedure <i>p</i> unqualified, a call to <i>p</i> outside of <i>M</i> can be simply <i>p</i> instead of the usual <i>M.p</i>. A class cannot export variables or dynamic constants unqualified (because each object of the class has its own copies of these). The only things a class can export unqualified are types and compile time constants. The keyword <b>unqualified</b> can be abbreviated to ~. which is pronounced as \"not dot\".</p>\n<p>\r\nThe keyword <b>pervasive</b>, which is only meaningful if <b>unqualified</b> is also present, specifies that the exported item is to be visible in subsequent scopes, in other words that it is not necessary to import it into internal modules, monitors and classes.</p>\n<p>\r\nThe keyword <b>opaque</b>, which can only precede type names, specifies that outside the module, monitor or class, the type is considered to be distinct from all other types. This means, for example, that if the type is an array, it cannot be subscripted outside of the module. See <b>module</b> declaration for an example that uses opaque types. In most cases, classes are preferable to opaque types.</p>\n<p>\r\nExported subprograms are considered to be <b>deferred</b>, meaning that expansions are allowed to override these subprograms. See also <b>deferred</b> subprograms. These can be overridden using the keyword <b>body</b> before the resolving subprogram body.</p>\n<p>\r\nA class cannot export items from its parent or it parent's ancestors. All exported item must be declared in the current class.</p>\n<p>\r\n</p>",
      "text_content": " Procedures, functions, variables, constants and types can be exported. Modules, monitors or classes canot be exported. Parentheses are allowed around the items in an export list, as in:\r\n\r\nThe following syntax specifies that each exported identifier can optionally be preceded by the keywords var, unqualified, pervasive and opaque. Of these, only opaque is available in Turing proper.\r\nThe form of howExport is:\r\n { exportMethod }\r\nThe form of exportMethod is one of:\r\n (a) var (b) unqualified (c) pervasive (d) opaque\r\nThe keyword var means that the exported variable can be changed outside of the exporting module, monitor or class. This keyword applies only to exported variables. For example, if string variable name is exported var from module M, name can be changed from outside of M by M.name := \"Surprise!\".\r\nThe keyword unqualified means that references to the exported item do not need to be prefixed by the name of the exporting item. For example, if module M exports procedure p unqualified, a call to p outside of M can be simply p instead of the usual M.p. A class cannot export variables or dynamic constants unqualified (because each object of the class has its own copies of these). The only things a class can export unqualified are types and compile time constants. The keyword unqualified can be abbreviated to ~. which is pronounced as \"not dot\".\r\nThe keyword pervasive, which is only meaningful if unqualified is also present, specifies that the exported item is to be visible in subsequent scopes, in other words that it is not necessary to import it into internal modules, monitors and classes.\r\nThe keyword opaque, which can only precede type names, specifies that outside the module, monitor or class, the type is considered to be distinct from all other types. This means, for example, that if the type is an array, it cannot be subscripted outside of the module. See module declaration for an example that uses opaque types. In most cases, classes are preferable to opaque types.\r\nExported subprograms are considered to be deferred, meaning that expansions are allowed to override these subprograms. See also deferred subprograms. These can be overridden using the keyword body before the resolving subprogram body.\r\nA class cannot export items from its parent or it parent's ancestors. All exported item must be declared in the current class.\r\n",
      "mdown_content": "Procedures, functions, variables, constants and types can be exported. Modules, monitors or classes canot be exported. Parentheses are allowed around the items in an export list, as in:\nThe following syntax specifies that each exported identifier can optionally be preceded by the keywords **var**, **unqualified**, **pervasive** and **opaque**. Of these, only **opaque** is available in Turing proper.\nThe form of *howExport* is:\n { *exportMethod* }\nThe form of *exportMethod* is one of:\n (a) **var** (b) **unqualified** (c) **pervasive** (d) **opaque**\nThe keyword **var** means that the exported variable can be changed outside of the exporting module, monitor or class. This keyword applies only to exported variables. For example, if string variable *name *is exported **var** from module *M*,* name *can be changed from outside of *M* by *M.name *:= \"*Surprise!*\".\nThe keyword **unqualified** means that references to the exported item do not need to be prefixed by the name of the exporting item. For example, if module *M* exports procedure *p* unqualified, a call to *p* outside of *M* can be simply *p* instead of the usual *M.p*. A class cannot export variables or dynamic constants unqualified (because each object of the class has its own copies of these). The only things a class can export unqualified are types and compile time constants. The keyword **unqualified** can be abbreviated to ~. which is pronounced as \"not dot\".\nThe keyword **pervasive**, which is only meaningful if **unqualified** is also present, specifies that the exported item is to be visible in subsequent scopes, in other words that it is not necessary to import it into internal modules, monitors and classes.\nThe keyword **opaque**, which can only precede type names, specifies that outside the module, monitor or class, the type is considered to be distinct from all other types. This means, for example, that if the type is an array, it cannot be subscripted outside of the module. See **module** declaration for an example that uses opaque types. In most cases, classes are preferable to opaque types.\nExported subprograms are considered to be **deferred**, meaning that expansions are allowed to override these subprograms. See also **deferred** subprograms. These can be overridden using the keyword **body** before the resolving subprogram body.\nA class cannot export items from its parent or it parent's ancestors. All exported item must be declared in the current class."
    },
    {
      "title": "Details",
      "raw_content": "You can export <b>all</b> from a module, monitor or a class. This means that every sibmle that is legal to export is exported. You may also qualify the all, as in <b>export opaque unqualified pervasive all</b> where the qualifiers are added to each export item (if it makes sense).<p>\r\nIf <b>all</b> is specified as the export item, no other item may be specified. Also, and <b>all</b> export affects only the module, monitor or class that it is given in. Any inheriting or implementing module, monitor or class does not export <b>all</b> unless they also specify it.</p>\n<p>\r\n</p>",
      "text_content": " You can export all from a module, monitor or a class. This means that every sibmle that is legal to export is exported. You may also qualify the all, as in export opaque unqualified pervasive all where the qualifiers are added to each export item (if it makes sense).\r\nIf all is specified as the export item, no other item may be specified. Also, and all export affects only the module, monitor or class that it is given in. Any inheriting or implementing module, monitor or class does not export all unless they also specify it.\r\n",
      "mdown_content": "You can export **all** from a module, monitor or a class. This means that every sibmle that is legal to export is exported. You may also qualify the all, as in **export opaque unqualified pervasive all** where the qualifiers are added to each export item (if it makes sense).\nIf **all** is specified as the export item, no other item may be specified. Also, and **all** export affects only the module, monitor or class that it is given in. Any inheriting or implementing module, monitor or class does not export **all** unless they also specify it."
    },
    {
      "title": "See also",
      "links": [
        "unit",
        "module",
        "monitor",
        "class",
        "import",
        "inherit",
        "implement",
        "implement",
        "deferred"
      ],
      "raw_content": "<b><a href=\"unit.html\">unit</a></b>, <b><a href=\"module.html\">module</a></b>, <b><a href=\"monitor.html\">monitor</a></b> and <b><a href=\"class.html\">class</a></b>. See also <b><a href=\"import.html\">import</a></b> list, <b><a href=\"inherit.html\">inherit</a></b> clause, <b><a href=\"implement.html\">implement</a></b> clause, <b><a href=\"implement.html\">implement</a></b> <b>by</b> clause and <b><a href=\"deferred.html\">deferred</a></b> subprogram.<p>\r\n</p>",
      "text_content": " unit, module, monitor and class. See also import list, inherit clause, implement clause, implement by clause and deferred subprogram.\r\n",
      "mdown_content": "**[unit.html](unit)**, **[module.html](module)**, **[monitor.html](monitor)** and **[class.html](class)**. See also **[import.html](import)** list, **[inherit.html](inherit)** clause, **[implement.html](implement)** clause, **[implement.html](implement)** **by** clause and **[deferred.html](deferred)** subprogram."
    }
  ]
}
