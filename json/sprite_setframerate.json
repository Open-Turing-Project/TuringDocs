{
  "title": "Sprite.SetFrameRate",
  "fileName": "sprite_setframerate",
  "sections": [
    {
      "title": "Syntax",
      "raw_content": "<font size=\"+1\"><b>Sprite.SetFrameRate</b> (<i>framesPerSec</i> : <b>int</b>)<p></p></font>",
      "text_content": "Sprite.SetFrameRate (framesPerSec : int)\r\n    ",
      "mdown_content": "**Sprite.SetFrameRate** (_framesPerSec_ : **int**)\n"
    },
    {
      "title": "Description",
      "raw_content": "Specifies the maximum number of times per second that sprite positions\r\n          will be changed on the screen.  The higher the number, the smoother\r\n          the animation will appear (and the more processor time will be used\r\n          to perform the animation).",
      "text_content": "Specifies the maximum number of times per second that sprite positions\r\n          will be changed on the screen.  The higher the number, the smoother\r\n          the animation will appear (and the more processor time will be used\r\n          to perform the animation).\r\n    ",
      "mdown_content": "Specifies the maximum number of times per second that sprite positionswill be changed on the screen.  The higher the number, the smootherthe animation will appear (and the more processor time will be usedto perform the animation)."
    },
    {
      "title": "Details",
      "raw_content": "When you change the position or appearance of a sprite, Turing does\r\n          not update the window immediately.  Instead, it waits a certain length\r\n          of time and then updates all sprites that have moved since the last\r\n          update.  This allows for relatively smooth animation.<p>\r\n          This means that you have a simple loop that calls Sprite.SetPosition\r\n          200 times a second, the image of the sprite on the screen is still\r\n          only being moved (by default) 33 times a second.\r\n          </p>\n<p>\r\n          You can specify how many times a second Turing checks to see if a \r\n          sprite has moved by using the <b>Sprite.SetFrameRate</b> procedure.\r\n          Rates of 5-10 will make the movement of the sprites seem very \r\n          choppy.  Rates of 100 are more or less completely smooth (the \r\n          maximum is 120) and most CRT's will not notice any difference after\r\n          60.  The default rate is 33 frames per second.  You should note that\r\n          if you set the rate higher than your computer can handle, every other\r\n          part of your program will slow down as Turing will be checking for\r\n          sprite movement rather than executing your program.\r\n          </p>\n<p>\r\n          A modern PC (2+ GHz with a decent graphics card) can probably handle\r\n          a frame rate of 60+, depending on the number of sprites.  A \r\n          Pentium III should probably use the default rate.  Slower machines\r\n          should probably use a lower rate (around 20).  Experimentation is\r\n          the best way to determine the ideal frame rate.</p>\n<p>\r\n    </p>",
      "text_content": "When you change the position or appearance of a sprite, Turing does\r\n          not update the window immediately.  Instead, it waits a certain length\r\n          of time and then updates all sprites that have moved since the last\r\n          update.  This allows for relatively smooth animation.\r\n          This means that you have a simple loop that calls Sprite.SetPosition\r\n          200 times a second, the image of the sprite on the screen is still\r\n          only being moved (by default) 33 times a second.\r\n          \r\n          You can specify how many times a second Turing checks to see if a \r\n          sprite has moved by using the Sprite.SetFrameRate procedure.\r\n          Rates of 5-10 will make the movement of the sprites seem very \r\n          choppy.  Rates of 100 are more or less completely smooth (the \r\n          maximum is 120) and most CRT's will not notice any difference after\r\n          60.  The default rate is 33 frames per second.  You should note that\r\n          if you set the rate higher than your computer can handle, every other\r\n          part of your program will slow down as Turing will be checking for\r\n          sprite movement rather than executing your program.\r\n          \r\n          A modern PC (2+ GHz with a decent graphics card) can probably handle\r\n          a frame rate of 60+, depending on the number of sprites.  A \r\n          Pentium III should probably use the default rate.  Slower machines\r\n          should probably use a lower rate (around 20).  Experimentation is\r\n          the best way to determine the ideal frame rate.\r\n    ",
      "mdown_content": "When you change the position or appearance of a sprite, Turing doesnot update the window immediately.  Instead, it waits a certain lengthof time and then updates all sprites that have moved since the lastupdate.  This allows for relatively smooth animation.\n\nThis means that you have a simple loop that calls Sprite.SetPosition200 times a second, the image of the sprite on the screen is stillonly being moved (by default) 33 times a second.\n\nYou can specify how many times a second Turing checks to see if a sprite has moved by using the **Sprite.SetFrameRate** procedure.Rates of 5-10 will make the movement of the sprites seem very choppy.  Rates of 100 are more or less completely smooth (the maximum is 120) and most CRT's will not notice any difference after60.  The default rate is 33 frames per second.  You should note thatif you set the rate higher than your computer can handle, every otherpart of your program will slow down as Turing will be checking forsprite movement rather than executing your program.\n\nA modern PC (2+ GHz with a decent graphics card) can probably handlea frame rate of 60+, depending on the number of sprites.  A Pentium III should probably use the default rate.  Slower machinesshould probably use a lower rate (around 20).  Experimentation isthe best way to determine the ideal frame rate.\n"
    },
    {
      "title": "Status",
      "raw_content": "Exported qualified.<p>\r\n          This means that you can only call the function by calling \r\n          <b>Sprite.SetFrameRate</b>, not by calling <b>SetFrameRate</b>.</p>\n<p>\r\n    </p>",
      "text_content": "Exported qualified.\r\n          This means that you can only call the function by calling \r\n          Sprite.SetFrameRate, not by calling SetFrameRate.\r\n    ",
      "mdown_content": "Exported qualified.\n\nThis means that you can only call the function by calling **Sprite.SetFrameRate**, not by calling **SetFrameRate**.\n"
    }
  ],
  "dependencies": [

  ]
}
