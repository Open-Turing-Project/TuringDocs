{
  "title": "assignability",
  "fileName": "assignability",
  "sections": [
    {
      "title": "Description",
      "raw_content": "A value, such as 24, is assignable to a variable, such as <i>i</i>, if certain rules are followed. These rules, given in detail below, are called the <i>assignability </i>rules. They must be followed in assignment statements as well as when passing values to non-<b>var</b> parameters.<p>\r\n</p>",
      "text_content": " A value, such as 24, is assignable to a variable, such as i, if certain rules are followed. These rules, given in detail below, are called the assignability rules. They must be followed in assignment statements as well as when passing values to non-var parameters.\r\n",
      "mdown_content": "A value, such as 24, is assignable to a variable, such as *i*, if certain rules are followed. These rules, given in detail below, are called the *assignability *rules. They must be followed in assignment statements as well as when passing values to non-**var** parameters."
    },
    {
      "title": "Example",
      "code": [
        "        var i : int\r\n        i := 24         % 24 is assignable to i\r\n        \r\n        var width : 0 .. 319\r\n        width := 3 * i      % 3 * i is assignable to width\r\n        \r\n        var a : array 1 .. 25 of string\r\n        a (i) := \"Ralph\"        % \"Ralph\" is assignable to a(i)\r\n        \r\n        var name : string (20)\r\n        name := a (i)       % a(i) is assignable to name\r\n        \r\n        \r\n        var b : array 1 .. 25 of string\r\n        b := a          % Array a is assignable to b\r\n        \r\n        type personType :\r\n            record\r\n                age : int\r\n                name : string (20)\r\n            end record\r\n        var r, s : personType\r\n        \r\n        s := r          % Record r is assignable to s"
      ],
      "raw_content": "<p>\r\n</p>",
      "text_content": "\r\n\r\n",
      "mdown_content": ""
    },
    {
      "title": "Details",
      "raw_content": "The expression on the right of := must be <i>assignable </i>to the variable on the left. An expression passed to a non-<b>var</b> parameter must be assignable to the corresponding parameter.<p>\r\nAn expression<i> </i>is defined to be <i>assignable </i>to a variable if the two <i>root </i>types are<i> equivalent</i> or if an integer value is being assigned to a <b>real</b> variable (in which case the integer value is automatically converted to <b>real</b>). Two types are considered to be equivalent if they are essentially the same type (see <i>equivalence </i>for the detailed definition of this term).</p>\n<p>\r\nIn most cases a <i>root</i> type is simply the type itself. The exceptions are subranges and strings. The <i>root</i> type of a subrange, such as 0 .. 319, is the type of its bounds (<b>int</b> type in this example). The <i>root</i> type of a string, such as the type <b>string</b>(9), is the most general string type, namely <b>string</b>.</p>\n<p>\r\nWhen a subrange variable, such as <i>width</i>, is used as an expression, for example on the right side of an assignment statement, its type is considered to be the <i>root</i> type (integer in this case) rather than the subrange. When an expression is assigned to a subrange variable such as <i>width</i>, the value (3*<i>i</i> in this example) must lie in the subrange. Analogously, any string variable used in an expression is considered to be of the most general type of string. When a string value is assigned to a string variable, its length must not exceed the variable's maximum length.</p>\n<p>\r\nTuring's assignability rule applies to characters and strings in this way. A <b>char</b> value can be assigned (or passed to an non <b>var</b> parameter) with automatic conversion to a <b>char</b>(1) variable and vice versa. String values of length 1 can be assigned to <b>char</b> variables. Character, that is <b>char</b>, values can be assigned to string variables, yielding a string of length 1. String values of length <i>n</i> are assignable with automatic conversion to <b>char</b>(<i>n</i>) variables. Values of type <b>char</b>(<i>n</i>) can be assigned with automatic conversion to <b>string</b> variables.</p>\n<p>\r\nTuring's assignability rule applies to pointers to classes in this way. A pointer that locates an object created as class <i>E</i>, can be assigned to a pointer to class <i>B</i> only if <i>B</i> is an ancestor of (or the same as) <i>E</i>. For example, a pointer to an object that is a <i>stackWithDepth</i> can be assigned to a pointer to <i>stack</i>, where <i>stackWithDepth</i> is a child of <i>stack</i>, but not vice versa. The pointer <b>nil</b> can be assigned to any pointer variable, but the value <b>nil</b>(<i>C</i>) can only be assigned to a pointer to an ancestor of C.</p>\n<p>\r\nObjects of classes can be assigned to each other only if both were created as the same class.</p>\n<p>\r\n</p>",
      "text_content": " The expression on the right of := must be assignable to the variable on the left. An expression passed to a non-var parameter must be assignable to the corresponding parameter.\r\nAn expression is defined to be assignable to a variable if the two root types are equivalent or if an integer value is being assigned to a real variable (in which case the integer value is automatically converted to real). Two types are considered to be equivalent if they are essentially the same type (see equivalence for the detailed definition of this term).\r\nIn most cases a root type is simply the type itself. The exceptions are subranges and strings. The root type of a subrange, such as 0 .. 319, is the type of its bounds (int type in this example). The root type of a string, such as the type string(9), is the most general string type, namely string.\r\nWhen a subrange variable, such as width, is used as an expression, for example on the right side of an assignment statement, its type is considered to be the root type (integer in this case) rather than the subrange. When an expression is assigned to a subrange variable such as width, the value (3*i in this example) must lie in the subrange. Analogously, any string variable used in an expression is considered to be of the most general type of string. When a string value is assigned to a string variable, its length must not exceed the variable's maximum length.\r\nTuring's assignability rule applies to characters and strings in this way. A char value can be assigned (or passed to an non var parameter) with automatic conversion to a char(1) variable and vice versa. String values of length 1 can be assigned to char variables. Character, that is char, values can be assigned to string variables, yielding a string of length 1. String values of length n are assignable with automatic conversion to char(n) variables. Values of type char(n) can be assigned with automatic conversion to string variables.\r\nTuring's assignability rule applies to pointers to classes in this way. A pointer that locates an object created as class E, can be assigned to a pointer to class B only if B is an ancestor of (or the same as) E. For example, a pointer to an object that is a stackWithDepth can be assigned to a pointer to stack, where stackWithDepth is a child of stack, but not vice versa. The pointer nil can be assigned to any pointer variable, but the value nil(C) can only be assigned to a pointer to an ancestor of C.\r\nObjects of classes can be assigned to each other only if both were created as the same class.\r\n",
      "mdown_content": "The expression on the right of := must be *assignable *to the variable on the left. An expression passed to a non-**var** parameter must be assignable to the corresponding parameter.\nAn expression* *is defined to be *assignable *to a variable if the two *root *types are* equivalent* or if an integer value is being assigned to a **real** variable (in which case the integer value is automatically converted to **real**). Two types are considered to be equivalent if they are essentially the same type (see *equivalence *for the detailed definition of this term).\nIn most cases a *root* type is simply the type itself. The exceptions are subranges and strings. The *root* type of a subrange, such as 0 .. 319, is the type of its bounds (**int** type in this example). The *root* type of a string, such as the type **string**(9), is the most general string type, namely **string**.\nWhen a subrange variable, such as *width*, is used as an expression, for example on the right side of an assignment statement, its type is considered to be the *root* type (integer in this case) rather than the subrange. When an expression is assigned to a subrange variable such as *width*, the value (3**i* in this example) must lie in the subrange. Analogously, any string variable used in an expression is considered to be of the most general type of string. When a string value is assigned to a string variable, its length must not exceed the variable's maximum length.\nTuring's assignability rule applies to characters and strings in this way. A **char** value can be assigned (or passed to an non **var** parameter) with automatic conversion to a **char**(1) variable and vice versa. String values of length 1 can be assigned to **char** variables. Character, that is **char**, values can be assigned to string variables, yielding a string of length 1. String values of length *n* are assignable with automatic conversion to **char**(*n*) variables. Values of type **char**(*n*) can be assigned with automatic conversion to **string** variables.\nTuring's assignability rule applies to pointers to classes in this way. A pointer that locates an object created as class *E*, can be assigned to a pointer to class *B* only if *B* is an ancestor of (or the same as) *E*. For example, a pointer to an object that is a *stackWithDepth* can be assigned to a pointer to *stack*, where *stackWithDepth* is a child of *stack*, but not vice versa. The pointer **nil** can be assigned to any pointer variable, but the value **nil**(*C*) can only be assigned to a pointer to an ancestor of C.\nObjects of classes can be assigned to each other only if both were created as the same class."
    }
  ]
}
