{
  "title": "handler",
  "fileName": "handler",
  "sections": [
    {
      "title": "Syntax",
      "raw_content": "A <i>exceptionHandler</i> is:<p>\r\n</p>\n<table>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"8\"><font size=\"+1\"><b>handler</b> ( <i>id </i>)</font></td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"7\"><font size=\"+1\"><i>statementsAndDeclarations</i></font></td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"8\"><font size=\"+1\"><b>end</b> <b>handler</b></font></td>\n</tr>\n</table>\n<p></p>",
      "text_content": " A exceptionHandler is:\r\n handler ( id )  statementsAndDeclarations end handler",
      "mdown_content": "A _exceptionHandler_ is:\n\n\n**handler** ( _id_ )\n_statementsAndDeclarations_\n**end** **handler**\n\n"
    },
    {
      "title": "Description",
      "raw_content": "An exception handler  is an optional block of statements and declarations in a subprogram (or process). It is activated when the program (or process) fails. This occurs, for example when dividing by zero.<p>\r\n</p>",
      "text_content": " An exception handler  is an optional block of statements and declarations in a subprogram (or process). It is activated when the program (or process) fails. This occurs, for example when dividing by zero.\r\n",
      "mdown_content": "An exception handler  is an optional block of statements and declarations in a subprogram (or process). It is activated when the program (or process) fails. This occurs, for example when dividing by zero.\n"
    },
    {
      "title": "Example",
      "code": [
        "        const stackOverflow := 500\r\n        const maxTop := 100\r\n        var top : 0 .. maxTop := 0\r\n        var stack : array 1 .. maxTop of int\r\n        \r\n        procedure push ( i : int )\r\n            if top = maxTop then\r\n                quit : stackOverflow\r\n            end if\r\n            top := top + 1\r\n            stack ( top ) := i\r\n        end push\r\n        \r\n        procedure parse\r\n            handler ( exceptionNumber )\r\n                put \"Failure number \", exceptionNumber\r\n                case exceptionNumber of\r\n                label stackOverflow :\r\n                    put \"Stack has overflowed!!\"\r\n                 other exceptions handled here \r\n                label :         % Unexpected failures\r\n                    quit >      % Pass exception further\r\n                end case\r\n            end handler\r\n            parseExpn           % Eventually push is called\r\n        end parse"
      ],
      "raw_content": "This program parses the input stream using a stack. If the stack overflows (its top exceeds its maximum), a <b>quit</b> statement in the <i>push</i> procedure aborts the parsing and gives control to the exception handler in the <i>parse</i> procedure. The <i>parse</i> procedure calls <i>parseExpn</i> which calls <i>push</i>. If <i>push</i> overflows the stack, it executes a <b>quit</b> and control is passed to the exception handler in the <i>parse </i>procedure. The interrupted procedures (<i>parseExpn</i> and <i>push</i>) are terminated and their local variables are deleted.<p>\r\n</p>",
      "text_content": " This program parses the input stream using a stack. If the stack overflows (its top exceeds its maximum), a quit statement in the push procedure aborts the parsing and gives control to the exception handler in the parse procedure. The parse procedure calls parseExpn which calls push. If push overflows the stack, it executes a quit and control is passed to the exception handler in the parse procedure. The interrupted procedures (parseExpn and push) are terminated and their local variables are deleted.\r\n\r\n",
      "mdown_content": "This program parses the input stream using a stack. If the stack overflows (its top exceeds its maximum), a **quit** statement in the _push_ procedure aborts the parsing and gives control to the exception handler in the _parse_ procedure. The _parse_ procedure calls _parseExpn_ which calls _push_. If _push_ overflows the stack, it executes a **quit** and control is passed to the exception handler in the _parse_ procedure. The interrupted procedures (_parseExpn_ and _push_) are terminated and their local variables are deleted.\n"
    },
    {
      "title": "Details",
      "code": [
        "        procedure [ pervasive ] id\r\n            [ ( [ paramDeclaration {,paramDeclaration } ] ) ]\r\n            [ import [ [var] id {, [var] id } ] ]\r\n            [ pre trueFalseExpn ]\r\n            [ init id := expn {, id := expn } ]\r\n            [ post trueFalseExpn ]\r\n            [ exceptionHandler ]\r\n            statementsAndDeclarations\r\n        end id"
      ],
      "raw_content": "See the <b>quit</b> statement for an explanation of its <i>quitReason</i> (<i>stackOverflow</i> in the first <b>quit</b> statement above) and its <i>guiltyParty </i>(&gt; in the second <b>quit</b> statement, meaning the exception is due to causes outside of this handler).<p>\r\nAn exception handler can appear only in the body of a subprogram (or process), just preceding the declarations and statements. The form of a procedure is:</p>\n<p>\r\n</p>\r\nExactly the same declarations and statements can appear in a handler as can appear in the subprogram body following the handler. In the absence of exceptions, handlers have no observable effect. A particular handler is activated (it becomes ready to handle an exception) when it is encountered during execution. It remains active until the subprogram (or process) containing it has completed, or the handler is given control. Activation of a handler when a previous handler is already active will cause exceptions to be passed to the newly-activated handler. In other words, handlers have a dynamic scope that begins when the exception handler is encountered and ends when the subprogram (or process) containing the handler has terminated or the handler is given control.<p>\r\nWhen a handler is given control, it becomes, in effect, a replacement for the declarations and statements following it. If the handler is in a function, it must terminate with a <b>result</b> statement or with a <b>quit</b>. If the handler is in a procedure (or process), the handler must terminate with a <b>return</b>, a <b>quit</b>, or by encountering the end of the handler (which is equivalent to a <b>return</b>).</p>\n<p>\r\nWhen a handler terminates with a <b>result</b> or <b>return</b> statement (or by reaching the end of a procedure's handler), the subprogram's <b>post</b> condition (if any) must be true. A <b>quit</b> statement does not need to establish the <b>post</b> condition.</p>\n<p>\r\nProgramming with exception handlers easily leads to incomprehensible software, due to the difficulty of keeping track of the flow of control. One of the most insidious situations is when an exception occurs in a module, class or monitor and is propagated outside of the unit. This can leave the contained data in an inconsistent state; in the case of a monitor, it is left locked forever. To avoid this possibility, you can use a handler in each exported subprogram. If an exception in a process is not handled, the entire program is aborted. If an implementation allocates dynamic arrays on the heap, an exception may prevent the deallocation of such an array.</p>\n<p>\r\nWithout exception handling, a program executes according to the language definition or else is aborted. If an exception handler is active, instead of aborting, control is given to the handler. The <i>quitNumber</i> for a system-detected failure is implementation-dependent. There is a file \"<i>%exceptions</i>\"<i> </i>which lists these numbers. The user program can simulate a system exception by doing a <b>quit</b> with the corresponding number.</p>\n<p>\r\nIf the user turns off checking  explicitly, the system may not detect failures. In some cases the failure may yield incorrect data or arbitrary behavior.</p>\n<p>\r\nSome exceptions are unpredictable or implementation-dependent. For example, in <i>x</i> := 24 div <i>i</i> + 24 / <i>i</i>, if <i>i</i> is zero, the exception could be either an integer or a real division by zero, because the order or evaluation is implementation-dependent.</p>\n<p>\r\n</p>",
      "text_content": " See the quit statement for an explanation of its quitReason (stackOverflow in the first quit statement above) and its guiltyParty (> in the second quit statement, meaning the exception is due to causes outside of this handler).\r\nAn exception handler can appear only in the body of a subprogram (or process), just preceding the declarations and statements. The form of a procedure is:\r\n\r\nExactly the same declarations and statements can appear in a handler as can appear in the subprogram body following the handler. In the absence of exceptions, handlers have no observable effect. A particular handler is activated (it becomes ready to handle an exception) when it is encountered during execution. It remains active until the subprogram (or process) containing it has completed, or the handler is given control. Activation of a handler when a previous handler is already active will cause exceptions to be passed to the newly-activated handler. In other words, handlers have a dynamic scope that begins when the exception handler is encountered and ends when the subprogram (or process) containing the handler has terminated or the handler is given control.\r\nWhen a handler is given control, it becomes, in effect, a replacement for the declarations and statements following it. If the handler is in a function, it must terminate with a result statement or with a quit. If the handler is in a procedure (or process), the handler must terminate with a return, a quit, or by encountering the end of the handler (which is equivalent to a return).\r\nWhen a handler terminates with a result or return statement (or by reaching the end of a procedure's handler), the subprogram's post condition (if any) must be true. A quit statement does not need to establish the post condition.\r\nProgramming with exception handlers easily leads to incomprehensible software, due to the difficulty of keeping track of the flow of control. One of the most insidious situations is when an exception occurs in a module, class or monitor and is propagated outside of the unit. This can leave the contained data in an inconsistent state; in the case of a monitor, it is left locked forever. To avoid this possibility, you can use a handler in each exported subprogram. If an exception in a process is not handled, the entire program is aborted. If an implementation allocates dynamic arrays on the heap, an exception may prevent the deallocation of such an array.\r\nWithout exception handling, a program executes according to the language definition or else is aborted. If an exception handler is active, instead of aborting, control is given to the handler. The quitNumber for a system-detected failure is implementation-dependent. There is a file \"%exceptions\" which lists these numbers. The user program can simulate a system exception by doing a quit with the corresponding number.\r\nIf the user turns off checking  explicitly, the system may not detect failures. In some cases the failure may yield incorrect data or arbitrary behavior.\r\nSome exceptions are unpredictable or implementation-dependent. For example, in x := 24 div i + 24 / i, if i is zero, the exception could be either an integer or a real division by zero, because the order or evaluation is implementation-dependent.\r\n",
      "mdown_content": "See the **quit** statement for an explanation of its _quitReason_ (_stackOverflow_ in the first **quit** statement above) and its _guiltyParty_ (> in the second **quit** statement, meaning the exception is due to causes outside of this handler).\n\nAn exception handler can appear only in the body of a subprogram (or process), just preceding the declarations and statements. The form of a procedure is:\n\nExactly the same declarations and statements can appear in a handler as can appear in the subprogram body following the handler. In the absence of exceptions, handlers have no observable effect. A particular handler is activated (it becomes ready to handle an exception) when it is encountered during execution. It remains active until the subprogram (or process) containing it has completed, or the handler is given control. Activation of a handler when a previous handler is already active will cause exceptions to be passed to the newly-activated handler. In other words, handlers have a dynamic scope that begins when the exception handler is encountered and ends when the subprogram (or process) containing the handler has terminated or the handler is given control.\n\nWhen a handler is given control, it becomes, in effect, a replacement for the declarations and statements following it. If the handler is in a function, it must terminate with a **result** statement or with a **quit**. If the handler is in a procedure (or process), the handler must terminate with a **return**, a **quit**, or by encountering the end of the handler (which is equivalent to a **return**).\n\nWhen a handler terminates with a **result** or **return** statement (or by reaching the end of a procedure's handler), the subprogram's **post** condition (if any) must be true. A **quit** statement does not need to establish the **post** condition.\n\nProgramming with exception handlers easily leads to incomprehensible software, due to the difficulty of keeping track of the flow of control. One of the most insidious situations is when an exception occurs in a module, class or monitor and is propagated outside of the unit. This can leave the contained data in an inconsistent state; in the case of a monitor, it is left locked forever. To avoid this possibility, you can use a handler in each exported subprogram. If an exception in a process is not handled, the entire program is aborted. If an implementation allocates dynamic arrays on the heap, an exception may prevent the deallocation of such an array.\n\nWithout exception handling, a program executes according to the language definition or else is aborted. If an exception handler is active, instead of aborting, control is given to the handler. The _quitNumber_ for a system-detected failure is implementation-dependent. There is a file \"_%exceptions_\" which lists these numbers. The user program can simulate a system exception by doing a **quit** with the corresponding number.\n\nIf the user turns off checking  explicitly, the system may not detect failures. In some cases the failure may yield incorrect data or arbitrary behavior.\n\nSome exceptions are unpredictable or implementation-dependent. For example, in _x_ := 24 div _i_ + 24 / _i_, if _i_ is zero, the exception could be either an integer or a real division by zero, because the order or evaluation is implementation-dependent.\n"
    }
  ],
  "dependencies": [

  ]
}
