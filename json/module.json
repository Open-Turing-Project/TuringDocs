{
  "title": "module",
  "fileName": "module",
  "sections": [
    {
      "title": "Syntax",
      "raw_content": "A <i>moduleDeclaration</i> is:<p>\r\n</p>\n<table>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"8\"><font size=\"+1\"><b>module</b> <i>id</i></font></td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"7\"><font size=\"+1\">[ <b>implement</b> <i>implementItem </i>]</font></td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"7\"><font size=\"+1\">[ <b>implement</b> <b>by</b> <i>implementByItem </i>]</font></td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"7\"><font size=\"+1\">[ <b>import</b> [ <b>var</b> ] <i>importItem</i> </font></td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td width=\"40\">&nbsp;</td>\n<td width=\"40\">&nbsp;</td>\n<td width=\"40\">&nbsp;</td>\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"4\"><font size=\"+1\">{,<i> </i>[ <b>var</b> ]<i> importItem</i> } ]</font></td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"7\"><font size=\"+1\">[ <b>export</b> [ <i>howExport</i> ] <i>id</i> {,[<i>howExport</i> ]<i> id</i> }]</font></td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"7\"><font size=\"+1\"><i>statementsAndDeclarations</i></font></td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"8\"><font size=\"+1\"><b>end</b> <i>id</i></font></td>\n</tr>\n</table>\n<p></p>",
      "text_content": " A moduleDeclaration is:\r\n module id  [ implement implementItem ]  [ implement by implementByItem ]  [ import [ var ] importItem      {, [ var ] importItem } ]  [ export [ howExport ] id {,[howExport ] id }]  statementsAndDeclarations end id",
      "mdown_content": "A *moduleDeclaration* is:\n **module** *id*  [ **implement** *implementItem *]  [ **implement** **by** *implementByItem *]  [ **import** [ **var** ] *importItem*      {,* *[ **var** ]* importItem* } ]  [ **export** [ *howExport* ] *id* {,[*howExport* ]* id* }]  *statementsAndDeclarations* **end** *id*"
    },
    {
      "title": "Description",
      "raw_content": "A module declaration creates a package of variables, constants, types, subprograms, etc. The name of the module (<i>id</i>) is given in two places, just after <b>module</b> and just after <b>end</b>. Items declared inside the module can be accessed outside of the module only if they are exported. Items from outside the module that are to be used in the module need to be imported (unless they are predefined or pervasive).<p>\r\n</p>",
      "text_content": " A module declaration creates a package of variables, constants, types, subprograms, etc. The name of the module (id) is given in two places, just after module and just after end. Items declared inside the module can be accessed outside of the module only if they are exported. Items from outside the module that are to be used in the module need to be imported (unless they are predefined or pervasive).\r\n",
      "mdown_content": "A module declaration creates a package of variables, constants, types, subprograms, etc. The name of the module (*id*) is given in two places, just after **module** and just after **end**. Items declared inside the module can be accessed outside of the module only if they are exported. Items from outside the module that are to be used in the module need to be imported (unless they are predefined or pervasive)."
    },
    {
      "title": "Example",
      "code": [
        "        module stack            % Implements a LIFO list of strings\r\n            export push, pop\r\n        \r\n            var top : int := 0\r\n            var contents : array 1 .. 100 of string\r\n        \r\n            procedure push ( s : string )\r\n                top := top + 1\r\n                contents ( top ) := s\r\n            end push\r\n        \r\n            procedure pop ( var s : string )\r\n                s := contents ( top )\r\n                top := top - 1\r\n            end pop\r\n        end stack\r\n        \r\n        stack . push ( \"Harvey\" )\r\n        var name : string\r\n        stack . pop ( name )        % This sets name to Harvey"
      ],
      "raw_content": "This module implements a stack of strings.<p>\r\n</p>\r\nOutside of the <i>stack</i> module, the procedures <i>push</i> and <i>pop</i> can be called using the notation <i>stack.push </i>and <i>stack.pop</i>. This access is allowed because <i>push</i> and <i>pop</i> are <i>exported</i> from the module. Other items declared in the module (<i>top</i> and <i>contents</i>) cannot be accessed from outside because they are not exported.<p>\r\n</p>",
      "text_content": " This module implements a stack of strings.\r\n\r\nOutside of the stack module, the procedures push and pop can be called using the notation stack.push and stack.pop. This access is allowed because push and pop are exported from the module. Other items declared in the module (top and contents) cannot be accessed from outside because they are not exported.\r\n",
      "mdown_content": "This module implements a stack of strings.\nOutside of the *stack* module, the procedures *push* and *pop* can be called using the notation *stack.push *and *stack.pop*. This access is allowed because *push* and *pop* are *exported* from the module. Other items declared in the module (*top* and *contents*) cannot be accessed from outside because they are not exported."
    },
    {
      "title": "Details",
      "raw_content": "In some other programming languages, a module is called a <i>package</i>,<i> cluster </i>or <i>object</i>.<p>\r\nA module declaration is executed (it is initialized) by executing its declarations and statements. For example, the <i>stack</i> module is initialized by setting the <i>top </i>variable to 0. This initialization executes all the statements and declarations in the module that are not contained in procedures or functions. The initialization is completed before any procedure or function of the module can be called from outside the module. An exported subprogram must not be called until initialization of the module is complete.</p>\n<p>\r\nA call to an exported procedure or function from outside the module executes the body of that procedure or function (the module is <i>not </i>initialized with each such call). See also <b>monitor</b> and <b>class</b> declarations.</p>\n<p>\r\nThe <b>import</b> list gives the names of items declared outside the module that can be accessed inside the module. Since <i>stack </i>has no <b>import</b> list, it is not allowed to access any names declared outside of it. See also <b>import</b> lists. Separately-compiled units that are imported are initialized before the importing unit.</p>\n<p>\r\nThe <b>export</b> list is used to implement <i>information hiding</i>, which isolates implementation details inside the module. The <b>export</b> list gives the names of items declared inside the module that can be used outside the module. For example, <i>push </i>and <i>pop</i> are exported from <i>stack</i>. Each such use of an exported item must be preceded by the module name and a dot, for example, <i>stack.push</i>. (See <b>unqualified</b> for advice on how to avoid using the prefix \"<i>stack.</i>\"). Names that are not exported, such as <i>top </i>and <i>contents</i>, cannot be accessed outside the module.</p>\n<p>\r\nProcedures, functions, variables, constants and types can be exported; modules, monitors or classes cannot be exported.</p>\n<p>\r\nA class is essentially a template for creating individual modules (objects). See <b>class</b> for details. A <b>monitor</b> is essentially a module in which only one process can be active at a time. See <b>monitor</b> and <b>process</b> for details.</p>\n<p>\r\nThe <b>opaque</b> keyword is used (only) in export lists to precede exported type names that have declarations in the module. Outside of the module, the type will be distinct from all others types. This means, for example, that if the opaque type is a record, its fields cannot be accessed outside of the module. Opaque types are used to guarantee that certain items are inspected and manipulated in only one place, namely, inside the module. These types are sometimes called <i>abstract data types</i>. See also <b>export</b> lists, which also describes <b>unqualified</b> and <b>pervasive</b> exports.</p>\n<p>\r\n<b>Implement</b> and i<b>mplement-by</b> lists are used to separate a module's interface from its body. This allows only a part of a module (its interface) to be visible to its users (its importers), while hiding its implementation. See <b>implement</b> and <b>implement</b> <b>by</b> lists.</p>\n<p>\r\n</p>",
      "text_content": " In some other programming languages, a module is called a package, cluster or object.\r\nA module declaration is executed (it is initialized) by executing its declarations and statements. For example, the stack module is initialized by setting the top variable to 0. This initialization executes all the statements and declarations in the module that are not contained in procedures or functions. The initialization is completed before any procedure or function of the module can be called from outside the module. An exported subprogram must not be called until initialization of the module is complete.\r\nA call to an exported procedure or function from outside the module executes the body of that procedure or function (the module is not initialized with each such call). See also monitor and class declarations.\r\nThe import list gives the names of items declared outside the module that can be accessed inside the module. Since stack has no import list, it is not allowed to access any names declared outside of it. See also import lists. Separately-compiled units that are imported are initialized before the importing unit.\r\nThe export list is used to implement information hiding, which isolates implementation details inside the module. The export list gives the names of items declared inside the module that can be used outside the module. For example, push and pop are exported from stack. Each such use of an exported item must be preceded by the module name and a dot, for example, stack.push. (See unqualified for advice on how to avoid using the prefix \"stack.\"). Names that are not exported, such as top and contents, cannot be accessed outside the module.\r\nProcedures, functions, variables, constants and types can be exported; modules, monitors or classes cannot be exported.\r\nA class is essentially a template for creating individual modules (objects). See class for details. A monitor is essentially a module in which only one process can be active at a time. See monitor and process for details.\r\nThe opaque keyword is used (only) in export lists to precede exported type names that have declarations in the module. Outside of the module, the type will be distinct from all others types. This means, for example, that if the opaque type is a record, its fields cannot be accessed outside of the module. Opaque types are used to guarantee that certain items are inspected and manipulated in only one place, namely, inside the module. These types are sometimes called abstract data types. See also export lists, which also describes unqualified and pervasive exports.\r\nImplement and implement-by lists are used to separate a module's interface from its body. This allows only a part of a module (its interface) to be visible to its users (its importers), while hiding its implementation. See implement and implement by lists.\r\n",
      "mdown_content": "In some other programming languages, a module is called a *package*,* cluster *or *object*.\nA module declaration is executed (it is initialized) by executing its declarations and statements. For example, the *stack* module is initialized by setting the *top *variable to 0. This initialization executes all the statements and declarations in the module that are not contained in procedures or functions. The initialization is completed before any procedure or function of the module can be called from outside the module. An exported subprogram must not be called until initialization of the module is complete.\nA call to an exported procedure or function from outside the module executes the body of that procedure or function (the module is *not *initialized with each such call). See also **monitor** and **class** declarations.\nThe **import** list gives the names of items declared outside the module that can be accessed inside the module. Since *stack *has no **import** list, it is not allowed to access any names declared outside of it. See also **import** lists. Separately-compiled units that are imported are initialized before the importing unit.\nThe **export** list is used to implement *information hiding*, which isolates implementation details inside the module. The **export** list gives the names of items declared inside the module that can be used outside the module. For example, *push *and *pop* are exported from *stack*. Each such use of an exported item must be preceded by the module name and a dot, for example, *stack.push*. (See **unqualified** for advice on how to avoid using the prefix \"*stack.*\"). Names that are not exported, such as *top *and *contents*, cannot be accessed outside the module.\nProcedures, functions, variables, constants and types can be exported; modules, monitors or classes cannot be exported.\nA class is essentially a template for creating individual modules (objects). See **class** for details. A **monitor** is essentially a module in which only one process can be active at a time. See **monitor** and **process** for details.\nThe **opaque** keyword is used (only) in export lists to precede exported type names that have declarations in the module. Outside of the module, the type will be distinct from all others types. This means, for example, that if the opaque type is a record, its fields cannot be accessed outside of the module. Opaque types are used to guarantee that certain items are inspected and manipulated in only one place, namely, inside the module. These types are sometimes called *abstract data types*. See also **export** lists, which also describes **unqualified** and **pervasive** exports.\n**Implement** and i**mplement-by** lists are used to separate a module's interface from its body. This allows only a part of a module (its interface) to be visible to its users (its importers), while hiding its implementation. See **implement** and **implement** **by** lists."
    },
    {
      "title": "Example",
      "code": [
        "        module complex\r\n            export opaque value, constant, add,\r\n                             other operations \r\n            type value :\r\n                record\r\n                    realPt, imagPt : real\r\n                end record\r\n        \r\n            function constant (realPt, imagPt: real ) : value\r\n                var answer : value\r\n                answer . realPt := realPt\r\n                answer . imagPt := imagPt\r\n                result answer\r\n            end constant\r\n        \r\n            function add (L, R : value ) : value\r\n                var answer : value\r\n                answer . realPt := L . realPt + R . realPt\r\n                answer . imagPt := L . imagPt + R . imagPt\r\n                result answer\r\n            end add\r\n        \r\n         other operations for complex arithmetic go here \r\n        end complex\r\n        \r\n        var c,d : complex .value :=complex.constant ( 1, 5 ) \r\n                % c and d become the complex number (1,5)\r\n        var e : complex .value := complex.add (c, d )\r\n                % e becomes the complex number (2,10)"
      ],
      "raw_content": "Use an <b>opaque</b> type to implement complex arithmetic.<p>\r\n</p>",
      "text_content": " Use an opaque type to implement complex arithmetic.\r\n\r\n",
      "mdown_content": "Use an **opaque** type to implement complex arithmetic."
    },
    {
      "title": "Details",
      "code": [
        "        module id\r\n            [ implement implementItem ]\r\n            [ implement by implementByItem ]\r\n            [ import [ var ] importItem {, [ var ] importItem } ]\r\n            [ export [ howExport ] id {, [ howExport ] id } ]\r\n            [ pre trueFalseExpn ]\r\n            statementsAndDeclarations\r\n            [ invariant trueFalseExpn ]\r\n            statementsAndDeclarations\r\n            [ post trueFalseExpn ]\r\n        end id"
      ],
      "raw_content": "Module declarations can be nested inside other modules but cannot be nested inside procedures or functions. A module must not contain a <b>bind</b> as one of its (outermost) declarations. A <b>return</b> statement cannot be used as one of the (outermost) statements in a module.<p>\r\nThe syntax of a <i>moduleDeclaration</i> presented above has been simplified by leaving out <b>pre</b>, <b>invariant</b> and <b>post</b> clauses; the full syntax<i> </i>is:</p>\n<p>\r\n</p>\r\nThe true/false expression in the <b>pre</b> and <b>post</b> clauses must be true when initialization reaches each of them. After that, these have no effect. The true/false expression in the <b>invariant</b> must be true any time the module is exited (when finishing initialization or when returning from an external call to an exported subprogram) or called (via an exported subprogram). These clauses (<b>pre</b>,<b>post</b> and <b>invariant</b>) are not inherited by expansions. For example, if module <i>B </i>inherits <i>A</i>,<i> </i>the subprograms of <i>B</i> are bound by <i>B</i>'s clauses and not by <i>A</i>'s.<p>\r\n</p>",
      "text_content": " Module declarations can be nested inside other modules but cannot be nested inside procedures or functions. A module must not contain a bind as one of its (outermost) declarations. A return statement cannot be used as one of the (outermost) statements in a module.\r\nThe syntax of a moduleDeclaration presented above has been simplified by leaving out pre, invariant and post clauses; the full syntax is:\r\n\r\nThe true/false expression in the pre and post clauses must be true when initialization reaches each of them. After that, these have no effect. The true/false expression in the invariant must be true any time the module is exited (when finishing initialization or when returning from an external call to an exported subprogram) or called (via an exported subprogram). These clauses (pre,post and invariant) are not inherited by expansions. For example, if module B inherits A, the subprograms of B are bound by B's clauses and not by A's.\r\n",
      "mdown_content": "Module declarations can be nested inside other modules but cannot be nested inside procedures or functions. A module must not contain a **bind** as one of its (outermost) declarations. A **return** statement cannot be used as one of the (outermost) statements in a module.\nThe syntax of a *moduleDeclaration* presented above has been simplified by leaving out **pre**, **invariant** and **post** clauses; the full syntax* *is:\nThe true/false expression in the **pre** and **post** clauses must be true when initialization reaches each of them. After that, these have no effect. The true/false expression in the **invariant** must be true any time the module is exited (when finishing initialization or when returning from an external call to an exported subprogram) or called (via an exported subprogram). These clauses (**pre**,**post** and **invariant**) are not inherited by expansions. For example, if module *B *inherits *A*,* *the subprograms of *B* are bound by *B*'s clauses and not by *A*'s."
    },
    {
      "title": "See also",
      "links": [
        "unit",
        "monitor",
        "class",
        "export",
        "import",
        "implement",
        "inherit",
        "deferred"
      ],
      "raw_content": "<b><a href=\"unit.html\">unit</a></b>, <b><a href=\"monitor.html\">monitor</a></b> and <b><a href=\"class.html\">class</a></b>. See also <b><a href=\"export.html\">export</a></b> list, <b><a href=\"import.html\">import</a></b> list, <b><a href=\"implement.html\">implement</a></b> list, i<b>mplement by</b> list, <b><a href=\"inherit.html\">inherit</a></b> list and <b><a href=\"deferred.html\">deferred</a></b> subprogram.<p>\r\n</p>",
      "text_content": " unit, monitor and class. See also export list, import list, implement list, implement by list, inherit list and deferred subprogram.\r\n",
      "mdown_content": "**[unit.html](unit)**, **[monitor.html](monitor)** and **[class.html](class)**. See also **[export.html](export)** list, **[import.html](import)** list, **[implement.html](implement)** list, i**mplement by** list, **[inherit.html](inherit)** list and **[deferred.html](deferred)** subprogram."
    }
  ],
  "dependencies": [

  ]
}
