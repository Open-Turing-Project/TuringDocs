{
  "title": "collection",
  "fileName": "collection",
  "sections": [
    {
      "title": "Syntax",
      "raw_content": "A <i>collectionDeclaration</i> is one of:<p>\r\n</p>\n<table>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td width=\"40\"><font size=\"+1\">(a)</font></td>\n<td colspan=\"7\"><font size=\"+1\"><b>var</b> <i>id </i>{ , <i>id </i>} : <b>collection</b> <b>of</b> <i>typeSpec</i></font></td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td width=\"40\"><font size=\"+1\">(b)</font></td>\n<td colspan=\"7\"><font size=\"+1\"><b>var</b> <i>id </i>{ , <i>id </i>} : <b>collection</b> <b>of</b> <b>forward</b> <i>typeId</i></font></td>\n</tr>\n</table>\n<p></p>",
      "text_content": " A collectionDeclaration is one of:\r\n (a)var id { , id } : collection of typeSpec (b)var id { , id } : collection of forward typeId",
      "mdown_content": "A *collectionDeclaration* is one of:\n (a)**var** *id *{ , *id *} : **collection** **of** *typeSpec* (b)**var** *id *{ , *id *} : **collection** **of** **forward** *typeId*"
    },
    {
      "title": "Description",
      "raw_content": "A collection declaration creates a new collection (or collections). A collection can be thought of as an array whose elements are dynamically created (by <b>new</b>) and deleted (by <b>free</b>). Elements of a collection are referred to by the collection's name subscripted by a pointer. See also <b>new</b>, <b>free</b> and <b>pointer</b>.<p>\r\n</p>",
      "text_content": " A collection declaration creates a new collection (or collections). A collection can be thought of as an array whose elements are dynamically created (by new) and deleted (by free). Elements of a collection are referred to by the collection's name subscripted by a pointer. See also new, free and pointer.\r\n",
      "mdown_content": "A collection declaration creates a new collection (or collections). A collection can be thought of as an array whose elements are dynamically created (by **new**) and deleted (by **free**). Elements of a collection are referred to by the collection's name subscripted by a pointer. See also **new**, **free** and **pointer**."
    },
    {
      "title": "Example",
      "code": [
        "        var tree : collection of\r\n            record\r\n                name : string (10)\r\n                left, right : pointer to tree\r\n            end record\r\n        \r\n        var root : pointer to tree\r\n        new tree, root\r\n        tree (root) . name := \"Adam\""
      ],
      "raw_content": "Create a collection that will represent a binary tree.<p>\r\n</p>",
      "text_content": " Create a collection that will represent a binary tree.\r\n\r\n",
      "mdown_content": "Create a collection that will represent a binary tree."
    },
    {
      "title": "Details",
      "raw_content": "The statement \"<b>new</b> <i>C</i>,<i>p</i>\" creates a new element in collection <i>C</i> and sets <i>p</i> to point at <i>i</i>. If there is no more memory space for the element, though, <i>p</i> is set to <i>nil</i> (<i>C</i>), which is the null pointer for collection <i>C</i>. The statement \"<b>free</b> <i>C</i>,<i>p</i>\" deletes the element of <i>C</i> pointed to by <i>p</i> and sets <i>p</i> to <i>nil</i> (<i>C</i>). In each case, <i>p</i> is passed as a <b>var</b> parameter and must be a variable of the pointer type of <i>C</i>.<p>\r\nThe keyword <b>forward</b> (form b above) is used to specify that the <i>typeId</i> of the collection elements will be given later in the collection's scope. The later declaration must appear at the same level (in the same list of declarations and statements) as the original declaration. This allows cyclic collections, for example, when a collection contains pointers to another collection, which in turn contains pointers to the first collection. In this case, the <i>typeId</i> is the name of the type that has not yet been declared; <i>typeId</i> cannot be used until its declaration appears. A collection whose element type is <b>forward</b> can be used only to declare pointers to it until the type's declaration is given.</p>\n<p>\r\nSuppose pointer <i>q</i> is equal to pointer <i>p</i> and the element they point to is deleted by \"<b>free</b> <i>C</i>,<i>p</i>\". We say <i>q</i> is a <i>dangling pointer</i> because it seems to locate an element, but the element no longer exists. A dangling pointer is considered to be an uninitialized value. It cannot be assigned, compared, used as a collection subscript, or passed to <b>free</b>.</p>\n<p>\r\nCollections cannot be assigned, compared, passed as parameters, bound to, or named by a <b>const</b> declaration. Collections must not be declared in procedures, functions, records or unions.</p>\n<p>\r\nThe same short forms for classes can be also used for collections. These include omission of the collection name in <b>new</b>, <b>free</b> and <b>nil</b> together with the ^ and -&gt; notations. Pointers to types (see <b>pointer</b>) can also be used, which are often more convenient to use than collections.</p>\n<p>\r\nThe syntax of a <i>collectionDeclaration</i> presented above has been simplified by leaving out <b>unchecked</b> collections. With this feature, a <i>collectionDeclaration</i> is one of:</p>\n<p>\r\n</p>\n<table>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td>(a) <b>var</b> <i>id </i>{ , <i>id </i>} : [ <b>unchecked</b> ] <b>collection</b> <b>of</b> <i>typeSpec</i>\n</td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td>(b)<i> </i><b>var</b> <i>id </i>{ , <i>id </i>} : [ <b>unchecked</b> ] <b>collection</b> <b>of</b> <b>forward</b> <i>typeId</i>\n</td>\n</tr>\n</table>\n<p>\r\nWhen <b>unchecked</b> is specified, the checking to verify that pointers actually locate elements is removed. This checking is done using a \"time stamp\" attached to each element and  pointer, and making sure that these match with each other. When <b>unchecked</b> is specified, the execution is dangerous, but faster and smaller, and the pointers become simply machine addresses (as in C).</p>\n<p>\r\n</p>",
      "text_content": " The statement \"new C,p\" creates a new element in collection C and sets p to point at i. If there is no more memory space for the element, though, p is set to nil (C), which is the null pointer for collection C. The statement \"free C,p\" deletes the element of C pointed to by p and sets p to nil (C). In each case, p is passed as a var parameter and must be a variable of the pointer type of C.\r\nThe keyword forward (form b above) is used to specify that the typeId of the collection elements will be given later in the collection's scope. The later declaration must appear at the same level (in the same list of declarations and statements) as the original declaration. This allows cyclic collections, for example, when a collection contains pointers to another collection, which in turn contains pointers to the first collection. In this case, the typeId is the name of the type that has not yet been declared; typeId cannot be used until its declaration appears. A collection whose element type is forward can be used only to declare pointers to it until the type's declaration is given.\r\nSuppose pointer q is equal to pointer p and the element they point to is deleted by \"free C,p\". We say q is a dangling pointer because it seems to locate an element, but the element no longer exists. A dangling pointer is considered to be an uninitialized value. It cannot be assigned, compared, used as a collection subscript, or passed to free.\r\nCollections cannot be assigned, compared, passed as parameters, bound to, or named by a const declaration. Collections must not be declared in procedures, functions, records or unions.\r\nThe same short forms for classes can be also used for collections. These include omission of the collection name in new, free and nil together with the ^ and -> notations. Pointers to types (see pointer) can also be used, which are often more convenient to use than collections.\r\nThe syntax of a collectionDeclaration presented above has been simplified by leaving out unchecked collections. With this feature, a collectionDeclaration is one of:\r\n (a) var id { , id } : [ unchecked ] collection of typeSpec (b) var id { , id } : [ unchecked ] collection of forward typeId\r\nWhen unchecked is specified, the checking to verify that pointers actually locate elements is removed. This checking is done using a \"time stamp\" attached to each element and  pointer, and making sure that these match with each other. When unchecked is specified, the execution is dangerous, but faster and smaller, and the pointers become simply machine addresses (as in C).\r\n",
      "mdown_content": "The statement \"**new** *C*,*p*\" creates a new element in collection *C* and sets *p* to point at *i*. If there is no more memory space for the element, though, *p* is set to *nil* (*C*), which is the null pointer for collection *C*. The statement \"**free** *C*,*p*\" deletes the element of *C* pointed to by *p* and sets *p* to *nil* (*C*). In each case, *p* is passed as a **var** parameter and must be a variable of the pointer type of *C*.\nThe keyword **forward** (form b above) is used to specify that the *typeId* of the collection elements will be given later in the collection's scope. The later declaration must appear at the same level (in the same list of declarations and statements) as the original declaration. This allows cyclic collections, for example, when a collection contains pointers to another collection, which in turn contains pointers to the first collection. In this case, the *typeId* is the name of the type that has not yet been declared; *typeId* cannot be used until its declaration appears. A collection whose element type is **forward** can be used only to declare pointers to it until the type's declaration is given.\nSuppose pointer *q* is equal to pointer *p* and the element they point to is deleted by \"**free** *C*,*p*\". We say *q* is a *dangling pointer* because it seems to locate an element, but the element no longer exists. A dangling pointer is considered to be an uninitialized value. It cannot be assigned, compared, used as a collection subscript, or passed to **free**.\nCollections cannot be assigned, compared, passed as parameters, bound to, or named by a **const** declaration. Collections must not be declared in procedures, functions, records or unions.\nThe same short forms for classes can be also used for collections. These include omission of the collection name in **new**, **free** and **nil** together with the ^ and -> notations. Pointers to types (see **pointer**) can also be used, which are often more convenient to use than collections.\nThe syntax of a *collectionDeclaration* presented above has been simplified by leaving out **unchecked** collections. With this feature, a *collectionDeclaration* is one of:\n (a) **var** *id *{ , *id *} : [ **unchecked** ] **collection** **of** *typeSpec* (b)* ***var** *id *{ , *id *} : [ **unchecked** ] **collection** **of** **forward** *typeId*\nWhen **unchecked** is specified, the checking to verify that pointers actually locate elements is removed. This checking is done using a \"time stamp\" attached to each element and  pointer, and making sure that these match with each other. When **unchecked** is specified, the execution is dangerous, but faster and smaller, and the pointers become simply machine addresses (as in C)."
    }
  ]
}
