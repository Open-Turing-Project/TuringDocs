{
  "title": "equivalence",
  "fileName": "equivalence",
  "sections": [
    {
      "title": "Description",
      "raw_content": "Two types are <i>equivalent</i> to each other if they are essentially the same types (the exact rules are given below). When a variable is passed to a <b>var</b> formal parameter, the types of the variable and the formal parameter must be equivalent because they are effectively the same variable. When an expression is assigned to a variable, their types must be equivalent, except for special cases. For example, Turing allows you to assign an integer expression to a <b>real</b> variable (see <i>assignability </i>for details).<p>\r\n</p>",
      "mdown_content": "Two types are *equivalent* to each other if they are essentially the same types (the exact rules are given below). When a variable is passed to a **var** formal parameter, the types of the variable and the formal parameter must be equivalent because they are effectively the same variable. When an expression is assigned to a variable, their types must be equivalent, except for special cases. For example, Turing allows you to assign an integer expression to a **real** variable (see *assignability *for details)."
    },
    {
      "title": "Example",
      "code": [
        "        var j : int\r\n        \r\n        var b : array 1 .. 25 of string\r\n        \r\n        type personType :\r\n            record\r\n                age : int\r\n                name : string (20)\r\n            end record\r\n        \r\n        procedure p (var i : int, var a : array 1 .. 25 of string,\r\n                    var r : personType)\r\n         body of procedure p, which modifies each of i, a and r \r\n        end p\r\n        \r\n        var s : personType\r\n        p (j, b, s)     % Procedure call to p\r\n                    % i and j have the equivalent type int\r\n                    % Arrays a and b have equivalent types\r\n                    % Records r and s have equivalent types"
      ],
      "raw_content": "<p>\r\n</p>",
      "mdown_content": ""
    },
    {
      "title": "Details",
      "raw_content": "Two types are defined to be <i>equivalent </i>if they are:<p>\r\n</p>\n<table>\n<tr valign=\"top\">\n<td>(a)</td>\n<td width=\"10\">&nbsp;</td>\n<td>the same standard type (<b>int</b>, <b>real</b>, <b>boolean</b> or <b>string</b>),</td>\n</tr>\n<tr valign=\"top\">\n<td>(b)</td>\n<td width=\"10\">&nbsp;</td>\n<td>subranges with equal first and last values,</td>\n</tr>\n<tr valign=\"top\">\n<td>(c)</td>\n<td width=\"10\">&nbsp;</td>\n<td>arrays with equivalent index types and equivalent component types,</td>\n</tr>\n<tr valign=\"top\">\n<td>(d)</td>\n<td width=\"10\">&nbsp;</td>\n<td>strings with equal maximum lengths,</td>\n</tr>\n<tr valign=\"top\">\n<td>(e)</td>\n<td width=\"10\">&nbsp;</td>\n<td>sets with equivalent base types, or</td>\n</tr>\n<tr valign=\"top\">\n<td>(f) </td>\n<td width=\"10\">&nbsp;</td>\n<td>pointers to the same collection; in addition,</td>\n</tr>\n<tr valign=\"top\">\n<td>(g)</td>\n<td width=\"10\">&nbsp;</td>\n<td>a declared type identifier is also equivalent to the type it names (and to the type named by that type, if that type is a named type, etc.)</td>\n</tr>\n<tr valign=\"top\">\n<td>(h)</td>\n<td width=\"10\">&nbsp;</td>\n<td>both <b>char</b>,</td>\n</tr>\n<tr valign=\"top\">\n<td>(i)</td>\n<td width=\"10\">&nbsp;</td>\n<td>both <b>char</b>(<i>n</i>) with the same length,</td>\n</tr>\n<tr valign=\"top\">\n<td>(j)</td>\n<td width=\"10\">&nbsp;</td>\n<td>both procedure types, with corresponding equivalent parameter types and corresponding <b>var</b> or non-<b>var</b> of the parameters,</td>\n</tr>\n<tr valign=\"top\">\n<td>(k)</td>\n<td width=\"10\">&nbsp;</td>\n<td>both function types, with corresponding equivalent parameter types and corresponding <b>var</b> or non-<b>var</b> of the parameters and equivalent result types,</td>\n</tr>\n<tr valign=\"top\">\n<td>(l)</td>\n<td width=\"10\">&nbsp;</td>\n<td>both pointer types to the same class or equivalent type and both are checked or unchecked.</td>\n</tr>\n</table>\n<p>\r\nEach separate instance of a record, union or enumerated type (written out using one of the keywords <b>record</b>, <b>union</b> or <b>enum</b>) creates a distinct type, equivalent to no other type. By contrast, separate instances of arrays, strings, subranges and sets are considered equivalent if their parts are equal and equivalent.</p>\n<p>\r\nOpaque type <i>T</i>, exported from a module, monitor or class <i>M</i> as <b>opaque</b>, is a special case of equivalence. Outside of <i>M</i> this type is written <i>M</i>.<i>T</i>, and is considered to be distinct from all other types. By contrast, if type <i>U </i>is exported non-<b>opaque</b>, the usual rules of equivalence apply. The parameter or result type of an exported procedure or function or an exported constant is considered to have type <i>M</i>.<i>T</i> outside of <i>M</i> if the item is declared using the type identifier <i>T</i>. Outside of <i>M</i>, the <b>opaque</b> type can be assigned, but not compared.</p>\n<p>\r\nIt is not required that subprogram types have the same names and parameter names to be equivalent. They also do not require the same factoring of parameters across their types, as in <i>i</i>,<i> j: </i><b>int</b> instead of <i>i: </i><b>int</b>,<i> j: </i><b>int</b>.</p>\n<p>\r\n</p>",
      "mdown_content": "Two types are defined to be *equivalent *if they are:\n\n(a)\n \nthe same standard type (**int**, **real**, **boolean** or **string**),\n(b)\n \nsubranges with equal first and last values,\n(c)\n \narrays with equivalent index types and equivalent component types,\n(d)\n \nstrings with equal maximum lengths,\n(e)\n \nsets with equivalent base types, or\n(f) \n \npointers to the same collection; in addition,\n(g)\n \na declared type identifier is also equivalent to the type it names (and to the type named by that type, if that type is a named type, etc.)\n(h)\n \nboth **char**,\n(i)\n \nboth **char**(*n*) with the same length,\n(j)\n \nboth procedure types, with corresponding equivalent parameter types and corresponding **var** or non-**var** of the parameters,\n(k)\n \nboth function types, with corresponding equivalent parameter types and corresponding **var** or non-**var** of the parameters and equivalent result types,\n(l)\n \nboth pointer types to the same class or equivalent type and both are checked or unchecked.\n\nEach separate instance of a record, union or enumerated type (written out using one of the keywords **record**, **union** or **enum**) creates a distinct type, equivalent to no other type. By contrast, separate instances of arrays, strings, subranges and sets are considered equivalent if their parts are equal and equivalent.\n\nOpaque type *T*, exported from a module, monitor or class *M* as **opaque**, is a special case of equivalence. Outside of *M* this type is written *M*.*T*, and is considered to be distinct from all other types. By contrast, if type *U *is exported non-**opaque**, the usual rules of equivalence apply. The parameter or result type of an exported procedure or function or an exported constant is considered to have type *M*.*T* outside of *M* if the item is declared using the type identifier *T*. Outside of *M*, the **opaque** type can be assigned, but not compared.\n\nIt is not required that subprogram types have the same names and parameter names to be equivalent. They also do not require the same factoring of parameters across their types, as in *i*,* j: ***int** instead of *i: ***int**,* j: ***int**.\n"
    }
  ]
}
