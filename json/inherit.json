{
  "title": "inherit",
  "fileName": "inherit",
  "sections": [
    {
      "title": "Syntax",
      "raw_content": "An <i>inheritClause </i>is:<p>\r\n</p>\n<table><tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"8\"><font size=\"+1\"><b>inherit</b> <i>inheritItem</i></font></td>\n</tr></table>\n<p></p>",
      "mdown_content": "An *inheritClause *is:\n\n \n**inherit** *inheritItem*"
    },
    {
      "title": "Description",
      "raw_content": "An <b>inherit</b> clause specifies that the class containing the clause is to be an expansion of another class. This expansion is called <i>inheritance</i>. The class containing the clause gains access to (inherits) all the declarations inside the target item. Expansions are used to add new declarations and exports and to support <i>polymorphism</i> (overriding subprograms).<p>\r\n</p>",
      "mdown_content": "An **inherit** clause specifies that the class containing the clause is to be an expansion of another class. This expansion is called *inheritance*. The class containing the clause gains access to (inherits) all the declarations inside the target item. Expansions are used to add new declarations and exports and to support *polymorphism* (overriding subprograms)."
    },
    {
      "title": "Example",
      "code": [
        "        class stack\r\n            export push, pop\r\n        \r\n            var top : int := 0\r\n            var contents : array 1 .. 100 of string\r\n        \r\n            procedure push ( s : string )\r\n                top := top + 1\r\n                contents (top ) := s\r\n            end push\r\n        \r\n            procedure pop ( var s : string )\r\n                s := contents ( top )\r\n                top := top - 1\r\n            end pop\r\n        end stack",
        "        class stackWithDepth\r\n            inherit stack\r\n            export depth\r\n            function depth : int\r\n                result top\r\n            end push\r\n        end stackWithDepth"
      ],
      "raw_content": "Here is an example of a stack class. Following it, we show another class, called <i>stackWithDepth</i>, that inherits <i>stack</i> by adding a function called <i>depth</i>.<p>\r\n</p>\r\nNext comes an expansion, which inherits the internal declarations of the stack class and adds the <i>depth</i> function.<p>\r\n</p>",
      "mdown_content": "Here is an example of a stack class. Following it, we show another class, called *stackWithDepth*, that inherits *stack* by adding a function called *depth*.\n\nNext comes an expansion, which inherits the internal declarations of the stack class and adds the *depth* function."
    },
    {
      "title": "Details",
      "code": [
        "        inherit ledger in \"newledg.t\"",
        "        inherit ( ledger in \"newledg.t\" )",
        "        B <= D      % B is an ancestor of D",
        "        B < D       % B is a strict ancestor of D",
        "        % Does the object located by p have the depth operation\r\n        if stackWithDepth <= objectclass(p) then"
      ],
      "raw_content": "Objects of the inherited class <i>stackWithDepth</i> are like objects of the parent class <i>stack</i>, except there is an additional exported function named <i>depth</i>.<p>\r\nAn <i>inheritItem</i> is one of:</p>\n<p>\r\n</p>\n<table>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td>(a) <i>id</i>\n</td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td>(b) <i>id</i> <b>in</b> <i>fileName</i>\n</td>\n</tr>\n</table>\n<p>\r\nThe second form is used when the inherit clause is for a separate <b>unit</b> and the imported item is in a file whose name is different from the item's name, for example:</p>\n<p>\r\n</p>\r\nThe <i>fileName</i> must be an explicit character string, e.g., \"<i>newledg.t</i>\". Parentheses are allowed around the item in an inherit clause, as in:<p>\r\n</p>\r\nThere is a special form of <b>inherit</b> clause, called an <b>implement</b> <b>clause</b>, that is used to separate an interface from an implementation. Modules and monitors, as well as classes, use these clauses. See <b>implement</b> clause and <b>implement</b> <b>by</b> clause.<p>\r\nIf class <i>D</i> inherits class <i>C</i>, we say that <i>C </i>is the <i>parent</i> and <i>D </i>is the <i>child</i>. Class <i>B</i> is said to be an <i>ancestor</i> of class <i>D </i>(and <i>D</i> is the <i>descendant</i> of <i>B</i>) if <i>B</i> and <i>D</i> are the same class, or if <i>B</i> is the parent of <i>D</i>, or if <i>B</i> is the parent of the parent of <i>D</i>, etc. We write this as follows:</p>\n<p>\r\n</p>\r\nIf <i>B</i> is an ancestor of <i>D</i> but not the same as <i>D</i>, we say <i>B</i> is a <i>strict</i> ancestor of <i>D</i>. We write this as:<p>\r\n</p>\r\nWe also use the notations <i>D</i> &gt;= <i>B</i>, <i>D</i> &gt; <i>B</i> and <i>D</i> = <i>B</i> with the obvious meanings. All of these notations can be used in a program. Their main use is in conjunction with <b>objectclass</b>, which determines the class of an object located by a pointer. For example, if <i>p</i> is declared to be a pointer to a <i>stack</i>, we can write the following to see if <i>p </i>currently locates an object with the <i>depth</i> operation:<p>\r\n</p>\r\nA pointer that locates an object created as class <i>E</i> can be assigned to a pointer to class <i>B</i>, only if <i>B</i> is an ancestor of <i>E</i>. For example, a pointer to an object that is a <i>stackWithDepth</i> can be assigned to a pointer to <i>stack</i>, but not vice versa. The pointer <b>nil</b> can be assigned to any pointer variable, but the value <b>nil</b>(<i>C</i>) can only be assigned to a pointer to an ancestor of C.<p>\r\nAn object (located by a pointer) can be assigned to another object only if they were created as objects of the same class. However, assignment of objects that are monitors or that contain dynamic arrays or collections is not allowed.</p>\n<p>\r\nCircular (recursive) inherits are not allowed. For example, if unit <i>B</i> inherits <i>A</i> then <i>A</i> cannot inherit <i>B</i>. Only one item is allowed in an inherit clause; in other words, Turing supports <i>single</i> inheritance but not <i>multiple</i> inheritance.</p>\n<p>\r\nSee <b>implement</b> clause for a special kind of expansion that separates a module, monitor or class' interface from its implementation. See <b>class</b> for an example of polymorphism, in which an inheriting class overrides subprograms of its parent class.</p>\n<p>\r\nThe initialization of a module, a monitor or an object is immediately preceded by the initialization of the item that it inherits or implements (if any). Correspondingly, if the item has an <b>implement</b> <b>by</b> clause, the implementation is initialized immediately after the initialization of the current item.</p>\n<p>\r\nWithin a class <i>C</i>, with ancestor <i>B</i>, you can force a call to exported subprogram <i>p</i> using the form <i>C.p</i> (or<i> B.p</i>). This calls the subprogram declared in <i>C</i> (or in <i>B</i> in the case of <i>B.p</i>), regardless of the actual class of the object and any overriding of <i>p</i>. This is similar to the notation <i>C</i>::<i>p</i> of the C++ language. This notation can only be used inside class <i>C</i>.</p>\n<p>\r\n</p>",
      "mdown_content": "Objects of the inherited class *stackWithDepth* are like objects of the parent class *stack*, except there is an additional exported function named *depth*.\nAn *inheritItem* is one of:\n\n\n \n(a) *id*\n\n \n(b) *id* **in** *fileName*\n\n\nThe second form is used when the inherit clause is for a separate **unit** and the imported item is in a file whose name is different from the item's name, for example:\n\n\nThe *fileName* must be an explicit character string, e.g., \"*newledg.t*\". Parentheses are allowed around the item in an inherit clause, as in:\n\nThere is a special form of **inherit** clause, called an **implement** **clause**, that is used to separate an interface from an implementation. Modules and monitors, as well as classes, use these clauses. See **implement** clause and **implement** **by** clause.\nIf class *D* inherits class *C*, we say that *C *is the *parent* and *D *is the *child*. Class *B* is said to be an *ancestor* of class *D *(and *D* is the *descendant* of *B*) if *B* and *D* are the same class, or if *B* is the parent of *D*, or if *B* is the parent of the parent of *D*, etc. We write this as follows:\n\n\nIf *B* is an ancestor of *D* but not the same as *D*, we say *B* is a *strict* ancestor of *D*. We write this as:\n\nWe also use the notations *D* >= *B*, *D* > *B* and *D* = *B* with the obvious meanings. All of these notations can be used in a program. Their main use is in conjunction with **objectclass**, which determines the class of an object located by a pointer. For example, if *p* is declared to be a pointer to a *stack*, we can write the following to see if *p *currently locates an object with the *depth* operation:\n\nA pointer that locates an object created as class *E* can be assigned to a pointer to class *B*, only if *B* is an ancestor of *E*. For example, a pointer to an object that is a *stackWithDepth* can be assigned to a pointer to *stack*, but not vice versa. The pointer **nil** can be assigned to any pointer variable, but the value **nil**(*C*) can only be assigned to a pointer to an ancestor of C.\nAn object (located by a pointer) can be assigned to another object only if they were created as objects of the same class. However, assignment of objects that are monitors or that contain dynamic arrays or collections is not allowed.\n\nCircular (recursive) inherits are not allowed. For example, if unit *B* inherits *A* then *A* cannot inherit *B*. Only one item is allowed in an inherit clause; in other words, Turing supports *single* inheritance but not *multiple* inheritance.\n\nSee **implement** clause for a special kind of expansion that separates a module, monitor or class' interface from its implementation. See **class** for an example of polymorphism, in which an inheriting class overrides subprograms of its parent class.\n\nThe initialization of a module, a monitor or an object is immediately preceded by the initialization of the item that it inherits or implements (if any). Correspondingly, if the item has an **implement** **by** clause, the implementation is initialized immediately after the initialization of the current item.\n\nWithin a class *C*, with ancestor *B*, you can force a call to exported subprogram *p* using the form *C.p* (or* B.p*). This calls the subprogram declared in *C* (or in *B* in the case of *B.p*), regardless of the actual class of the object and any overriding of *p*. This is similar to the notation *C*::*p* of the C++ language. This notation can only be used inside class *C*.\n"
    },
    {
      "title": "See also",
      "links": [
        "unit",
        "module",
        "monitor",
        "class",
        "export",
        "import",
        "implement",
        "implement_by",
        "deferred",
        "objectclass"
      ],
      "raw_content": "<b><a href=\"unit.html\">unit</a></b>, <b><a href=\"module.html\">module</a></b>, <b><a href=\"monitor.html\">monitor</a></b> and <b><a href=\"class.html\">class</a></b>. See also <b><a href=\"export.html\">export</a></b> list, <b><a href=\"import.html\">import</a></b> list, <b><a href=\"implement.html\">implement</a></b> clause, <b><a href=\"implement_by.html\">implement by</a></b> clause and <b><a href=\"deferred.html\">deferred</a></b> subprogram. See also <b><a href=\"objectclass.html\">objectclass</a></b>.<p>\r\n</p>",
      "mdown_content": "**[unit.html](unit)**, **[module.html](module)**, **[monitor.html](monitor)** and **[class.html](class)**. See also **[export.html](export)** list, **[import.html](import)** list, **[implement.html](implement)** clause, **[implement_by.html](implement by)** clause and **[deferred.html](deferred)** subprogram. See also **[objectclass.html](objectclass)**."
    }
  ]
}
