{
  "title": "inherit",
  "fileName": "inherit",
  "sections": [
    {
      "title": "Syntax",
      "raw_content": "An <i>inheritClause </i>is:<p>\r\n</p>\n<table><tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"8\"><font size=\"+1\"><b>inherit</b> <i>inheritItem</i></font></td>\n</tr></table>\n<p></p>",
      "text_content": " An inheritClause is:\r\n inherit inheritItem",
      "mdown_content": "An _inheritClause_ is:\n\n\n**inherit** _inheritItem_\n\n"
    },
    {
      "title": "Description",
      "raw_content": "An <b>inherit</b> clause specifies that the class containing the clause is to be an expansion of another class. This expansion is called <i>inheritance</i>. The class containing the clause gains access to (inherits) all the declarations inside the target item. Expansions are used to add new declarations and exports and to support <i>polymorphism</i> (overriding subprograms).<p>\r\n</p>",
      "text_content": " An inherit clause specifies that the class containing the clause is to be an expansion of another class. This expansion is called inheritance. The class containing the clause gains access to (inherits) all the declarations inside the target item. Expansions are used to add new declarations and exports and to support polymorphism (overriding subprograms).\r\n",
      "mdown_content": "An **inherit** clause specifies that the class containing the clause is to be an expansion of another class. This expansion is called _inheritance_. The class containing the clause gains access to (inherits) all the declarations inside the target item. Expansions are used to add new declarations and exports and to support _polymorphism_ (overriding subprograms).\n"
    },
    {
      "title": "Example",
      "code": [
        "        class stack\r\n            export push, pop\r\n        \r\n            var top : int := 0\r\n            var contents : array 1 .. 100 of string\r\n        \r\n            procedure push ( s : string )\r\n                top := top + 1\r\n                contents (top ) := s\r\n            end push\r\n        \r\n            procedure pop ( var s : string )\r\n                s := contents ( top )\r\n                top := top - 1\r\n            end pop\r\n        end stack",
        "        class stackWithDepth\r\n            inherit stack\r\n            export depth\r\n            function depth : int\r\n                result top\r\n            end push\r\n        end stackWithDepth"
      ],
      "raw_content": "Here is an example of a stack class. Following it, we show another class, called <i>stackWithDepth</i>, that inherits <i>stack</i> by adding a function called <i>depth</i>.<p>\r\n</p>\r\nNext comes an expansion, which inherits the internal declarations of the stack class and adds the <i>depth</i> function.<p>\r\n</p>",
      "text_content": " Here is an example of a stack class. Following it, we show another class, called stackWithDepth, that inherits stack by adding a function called depth.\r\n\r\nNext comes an expansion, which inherits the internal declarations of the stack class and adds the depth function.\r\n\r\n",
      "mdown_content": "Here is an example of a stack class. Following it, we show another class, called _stackWithDepth_, that inherits _stack_ by adding a function called _depth_.\n\nNext comes an expansion, which inherits the internal declarations of the stack class and adds the _depth_ function.\n"
    },
    {
      "title": "Details",
      "code": [
        "        inherit ledger in \"newledg.t\"",
        "        inherit ( ledger in \"newledg.t\" )",
        "        B <= D      % B is an ancestor of D",
        "        B < D       % B is a strict ancestor of D",
        "        % Does the object located by p have the depth operation\r\n        if stackWithDepth <= objectclass(p) then"
      ],
      "raw_content": "Objects of the inherited class <i>stackWithDepth</i> are like objects of the parent class <i>stack</i>, except there is an additional exported function named <i>depth</i>.<p>\r\nAn <i>inheritItem</i> is one of:</p>\n<p>\r\n</p>\n<table>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td>(a) <i>id</i>\n</td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td>(b) <i>id</i> <b>in</b> <i>fileName</i>\n</td>\n</tr>\n</table>\n<p>\r\nThe second form is used when the inherit clause is for a separate <b>unit</b> and the imported item is in a file whose name is different from the item's name, for example:</p>\n<p>\r\n</p>\r\nThe <i>fileName</i> must be an explicit character string, e.g., \"<i>newledg.t</i>\". Parentheses are allowed around the item in an inherit clause, as in:<p>\r\n</p>\r\nThere is a special form of <b>inherit</b> clause, called an <b>implement</b> <b>clause</b>, that is used to separate an interface from an implementation. Modules and monitors, as well as classes, use these clauses. See <b>implement</b> clause and <b>implement</b> <b>by</b> clause.<p>\r\nIf class <i>D</i> inherits class <i>C</i>, we say that <i>C </i>is the <i>parent</i> and <i>D </i>is the <i>child</i>. Class <i>B</i> is said to be an <i>ancestor</i> of class <i>D </i>(and <i>D</i> is the <i>descendant</i> of <i>B</i>) if <i>B</i> and <i>D</i> are the same class, or if <i>B</i> is the parent of <i>D</i>, or if <i>B</i> is the parent of the parent of <i>D</i>, etc. We write this as follows:</p>\n<p>\r\n</p>\r\nIf <i>B</i> is an ancestor of <i>D</i> but not the same as <i>D</i>, we say <i>B</i> is a <i>strict</i> ancestor of <i>D</i>. We write this as:<p>\r\n</p>\r\nWe also use the notations <i>D</i> &gt;= <i>B</i>, <i>D</i> &gt; <i>B</i> and <i>D</i> = <i>B</i> with the obvious meanings. All of these notations can be used in a program. Their main use is in conjunction with <b>objectclass</b>, which determines the class of an object located by a pointer. For example, if <i>p</i> is declared to be a pointer to a <i>stack</i>, we can write the following to see if <i>p </i>currently locates an object with the <i>depth</i> operation:<p>\r\n</p>\r\nA pointer that locates an object created as class <i>E</i> can be assigned to a pointer to class <i>B</i>, only if <i>B</i> is an ancestor of <i>E</i>. For example, a pointer to an object that is a <i>stackWithDepth</i> can be assigned to a pointer to <i>stack</i>, but not vice versa. The pointer <b>nil</b> can be assigned to any pointer variable, but the value <b>nil</b>(<i>C</i>) can only be assigned to a pointer to an ancestor of C.<p>\r\nAn object (located by a pointer) can be assigned to another object only if they were created as objects of the same class. However, assignment of objects that are monitors or that contain dynamic arrays or collections is not allowed.</p>\n<p>\r\nCircular (recursive) inherits are not allowed. For example, if unit <i>B</i> inherits <i>A</i> then <i>A</i> cannot inherit <i>B</i>. Only one item is allowed in an inherit clause; in other words, Turing supports <i>single</i> inheritance but not <i>multiple</i> inheritance.</p>\n<p>\r\nSee <b>implement</b> clause for a special kind of expansion that separates a module, monitor or class' interface from its implementation. See <b>class</b> for an example of polymorphism, in which an inheriting class overrides subprograms of its parent class.</p>\n<p>\r\nThe initialization of a module, a monitor or an object is immediately preceded by the initialization of the item that it inherits or implements (if any). Correspondingly, if the item has an <b>implement</b> <b>by</b> clause, the implementation is initialized immediately after the initialization of the current item.</p>\n<p>\r\nWithin a class <i>C</i>, with ancestor <i>B</i>, you can force a call to exported subprogram <i>p</i> using the form <i>C.p</i> (or<i> B.p</i>). This calls the subprogram declared in <i>C</i> (or in <i>B</i> in the case of <i>B.p</i>), regardless of the actual class of the object and any overriding of <i>p</i>. This is similar to the notation <i>C</i>::<i>p</i> of the C++ language. This notation can only be used inside class <i>C</i>.</p>\n<p>\r\n</p>",
      "text_content": " Objects of the inherited class stackWithDepth are like objects of the parent class stack, except there is an additional exported function named depth.\r\nAn inheritItem is one of:\r\n (a) id (b) id in fileName\r\nThe second form is used when the inherit clause is for a separate unit and the imported item is in a file whose name is different from the item's name, for example:\r\n\r\nThe fileName must be an explicit character string, e.g., \"newledg.t\". Parentheses are allowed around the item in an inherit clause, as in:\r\n\r\nThere is a special form of inherit clause, called an implement clause, that is used to separate an interface from an implementation. Modules and monitors, as well as classes, use these clauses. See implement clause and implement by clause.\r\nIf class D inherits class C, we say that C is the parent and D is the child. Class B is said to be an ancestor of class D (and D is the descendant of B) if B and D are the same class, or if B is the parent of D, or if B is the parent of the parent of D, etc. We write this as follows:\r\n\r\nIf B is an ancestor of D but not the same as D, we say B is a strict ancestor of D. We write this as:\r\n\r\nWe also use the notations D >= B, D > B and D = B with the obvious meanings. All of these notations can be used in a program. Their main use is in conjunction with objectclass, which determines the class of an object located by a pointer. For example, if p is declared to be a pointer to a stack, we can write the following to see if p currently locates an object with the depth operation:\r\n\r\nA pointer that locates an object created as class E can be assigned to a pointer to class B, only if B is an ancestor of E. For example, a pointer to an object that is a stackWithDepth can be assigned to a pointer to stack, but not vice versa. The pointer nil can be assigned to any pointer variable, but the value nil(C) can only be assigned to a pointer to an ancestor of C.\r\nAn object (located by a pointer) can be assigned to another object only if they were created as objects of the same class. However, assignment of objects that are monitors or that contain dynamic arrays or collections is not allowed.\r\nCircular (recursive) inherits are not allowed. For example, if unit B inherits A then A cannot inherit B. Only one item is allowed in an inherit clause; in other words, Turing supports single inheritance but not multiple inheritance.\r\nSee implement clause for a special kind of expansion that separates a module, monitor or class' interface from its implementation. See class for an example of polymorphism, in which an inheriting class overrides subprograms of its parent class.\r\nThe initialization of a module, a monitor or an object is immediately preceded by the initialization of the item that it inherits or implements (if any). Correspondingly, if the item has an implement by clause, the implementation is initialized immediately after the initialization of the current item.\r\nWithin a class C, with ancestor B, you can force a call to exported subprogram p using the form C.p (or B.p). This calls the subprogram declared in C (or in B in the case of B.p), regardless of the actual class of the object and any overriding of p. This is similar to the notation C::p of the C++ language. This notation can only be used inside class C.\r\n",
      "mdown_content": "Objects of the inherited class _stackWithDepth_ are like objects of the parent class _stack_, except there is an additional exported function named _depth_.\n\nAn _inheritItem_ is one of:\n\n\n(a) _id_\n(b) _id_ **in** _fileName_\n\n\nThe second form is used when the inherit clause is for a separate **unit** and the imported item is in a file whose name is different from the item's name, for example:\n\nThe _fileName_ must be an explicit character string, e.g., \"_newledg.t_\". Parentheses are allowed around the item in an inherit clause, as in:\n\nThere is a special form of **inherit** clause, called an **implement** **clause**, that is used to separate an interface from an implementation. Modules and monitors, as well as classes, use these clauses. See **implement** clause and **implement** **by** clause.\n\nIf class _D_ inherits class _C_, we say that _C_ is the _parent_ and _D_ is the _child_. Class _B_ is said to be an _ancestor_ of class _D_ (and _D_ is the _descendant_ of _B_) if _B_ and _D_ are the same class, or if _B_ is the parent of _D_, or if _B_ is the parent of the parent of _D_, etc. We write this as follows:\n\nIf _B_ is an ancestor of _D_ but not the same as _D_, we say _B_ is a _strict_ ancestor of _D_. We write this as:\n\nWe also use the notations _D_ >= _B_, _D_ > _B_ and _D_ = _B_ with the obvious meanings. All of these notations can be used in a program. Their main use is in conjunction with **objectclass**, which determines the class of an object located by a pointer. For example, if _p_ is declared to be a pointer to a _stack_, we can write the following to see if _p_ currently locates an object with the _depth_ operation:\n\nA pointer that locates an object created as class _E_ can be assigned to a pointer to class _B_, only if _B_ is an ancestor of _E_. For example, a pointer to an object that is a _stackWithDepth_ can be assigned to a pointer to _stack_, but not vice versa. The pointer **nil** can be assigned to any pointer variable, but the value **nil**(_C_) can only be assigned to a pointer to an ancestor of C.\n\nAn object (located by a pointer) can be assigned to another object only if they were created as objects of the same class. However, assignment of objects that are monitors or that contain dynamic arrays or collections is not allowed.\n\nCircular (recursive) inherits are not allowed. For example, if unit _B_ inherits _A_ then _A_ cannot inherit _B_. Only one item is allowed in an inherit clause; in other words, Turing supports _single_ inheritance but not _multiple_ inheritance.\n\nSee **implement** clause for a special kind of expansion that separates a module, monitor or class' interface from its implementation. See **class** for an example of polymorphism, in which an inheriting class overrides subprograms of its parent class.\n\nThe initialization of a module, a monitor or an object is immediately preceded by the initialization of the item that it inherits or implements (if any). Correspondingly, if the item has an **implement** **by** clause, the implementation is initialized immediately after the initialization of the current item.\n\nWithin a class _C_, with ancestor _B_, you can force a call to exported subprogram _p_ using the form _C.p_ (or _B.p_). This calls the subprogram declared in _C_ (or in _B_ in the case of _B.p_), regardless of the actual class of the object and any overriding of _p_. This is similar to the notation _C_::_p_ of the C++ language. This notation can only be used inside class _C_.\n"
    },
    {
      "title": "See also",
      "links": [
        "unit",
        "module",
        "monitor",
        "class",
        "export",
        "import",
        "implement",
        "implement_by",
        "deferred",
        "objectclass"
      ],
      "raw_content": "<b><a href=\"unit.html\">unit</a></b>, <b><a href=\"module.html\">module</a></b>, <b><a href=\"monitor.html\">monitor</a></b> and <b><a href=\"class.html\">class</a></b>. See also <b><a href=\"export.html\">export</a></b> list, <b><a href=\"import.html\">import</a></b> list, <b><a href=\"implement.html\">implement</a></b> clause, <b><a href=\"implement_by.html\">implement by</a></b> clause and <b><a href=\"deferred.html\">deferred</a></b> subprogram. See also <b><a href=\"objectclass.html\">objectclass</a></b>.<p>\r\n</p>",
      "text_content": " unit, module, monitor and class. See also export list, import list, implement clause, implement by clause and deferred subprogram. See also objectclass.\r\n",
      "mdown_content": "**[unit.html](unit)**, **[module.html](module)**, **[monitor.html](monitor)** and **[class.html](class)**. See also **[export.html](export)** list, **[import.html](import)** list, **[implement.html](implement)** clause, **[implement_by.html](implement by)** clause and **[deferred.html](deferred)** subprogram. See also **[objectclass.html](objectclass)**.\n"
    }
  ],
  "dependencies": [

  ]
}
