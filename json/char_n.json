{
  "title": "char(n)",
  "fileName": "char_n",
  "sections": [
    {
      "title": "Syntax",
      "raw_content": "<font size=\"+1\"><b>char</b> (<i>numberOfCharacters</i>)<p>\r\n</p></font>",
      "text_content": " char (numberOfCharacters)\r\n",
      "mdown_content": "**char** (_numberOfCharacters_)"
    },
    {
      "title": "Description",
      "raw_content": "Each variable whose type is a <b>char</b>(<i>n</i>) contains exactly <i>n</i> characters.<p>\r\n</p>",
      "text_content": " Each variable whose type is a char(n) contains exactly n characters.\r\n",
      "mdown_content": "Each variable whose type is a **char**(_n_) contains exactly _n_ characters."
    },
    {
      "title": "Example",
      "code": [
        "        var postalCode : char (6) := 'M4V1Y9'"
      ],
      "raw_content": "Canadian postal codes contain six characters, for example, M4V 1Y9. This is represented in a <b>char</b>(6) variable:<p>\r\n</p>",
      "text_content": " Canadian postal codes contain six characters, for example, M4V 1Y9. This is represented in a char(6) variable:\r\n\r\n",
      "mdown_content": "Canadian postal codes contain six characters, for example, M4V 1Y9. This is represented in a **char**(6) variable:"
    },
    {
      "title": "Details",
      "raw_content": "Explicit constants for the <b>char</b>(<i>n</i>) type use single quotes as in 'M4V1Y9', as opposed to explicit <b>string</b> constants which use double quotes, as in \"Nancy\". A single character single quoted character, such as 'A', is considered to have the type <b>char</b> instead of <b>char</b>(<i>n</i>), but since these two types can be assigned to each other and compared to each other, this fact has little consequence.<p>\r\nThe type <b>char</b>(<i>n</i>) is generally more difficult to use than the <b>string</b> type, which is favored for most simple programs. The type <b>char</b>(<i>n</i>) has the advantage that it is efficient in terms of both space and time. In particular, it is represented as <i>n</i> bytes in the computer's memory. By contrast, the <b>string</b> type must use extra space (a trailing zero byte in current implementations) to represent the current length and allocates space for the maximum value it can hold.</p>\n<p>\r\nThe form of <i>numberOfCharacters</i> is one of:</p>\n<p>\r\n</p>\n<table>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td>(a) <i>expn</i>\n</td>\n<td width=\"10\">&nbsp;</td>\n<td><i>% Integer value</i></td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td>(b) *</td>\n<td width=\"10\">&nbsp;</td>\n<td><i>% Only in subprogram parameters</i></td>\n</tr>\n</table>\n<p>\r\nThe first form determines <i>n</i>. If the expression is a run time value, the type is considered to be <i>dynamic</i> <b>char</b>(<i>n</i>). The value of <i>n</i> must be at least 1. The second form is used only for subprogram parameters and uses the length of the actual parameter. This too, is considered to be a<i> dynamic</i> <b>char</b>(<i>n</i>) type. Dynamic <b>char</b>(<i>n</i>) types can only be passed to <b>char</b>(*) parameters. Dynamic <b>char</b>(<i>n</i>) types have the same restrictions as dynamic arrays. This implies they cannot be assigned as a whole and cannot appear in record and union types.</p>\n<p>\r\nAn implementation may impose a limit, recommended to be at least 32767, on the length <i>n</i>.</p>\n<p>\r\nValues of the <b>char</b>(<i>n</i>) type can be assigned and they can be compared for both equality and for ordering, but only if they have the same length and they are not dynamic (i.e. the length must be known at compile time).</p>\n<p>\r\nValues of the <b>char</b>(<i>n</i>) type can be read and written by <b>get</b> and <b>put</b> statements.</p>\n<p>\r\nThe <b>char</b>(<i>n</i>) type is a nonscalar, which implies that its parameters are always passed by reference (by means of an implicit pointer).</p>\n<p>\r\nAs is true for the <b>char</b> type, all 256 possible values of an 8-bit byte are allowed for each character in <b>char</b>(<i>n</i>) type. There is no pattern left to be used for the \"initialized value\", so there is no uninitialized checking for <b>char</b>(<i>n</i>).</p>\n<p>\r\nIn general, you can freely intermix the values of the types <b>char</b>, <b>char</b>(<i>n</i>) and <b>string</b>. This means that catenation (+), comparisons, <b>length</b> and substrings can be applied to any of these types. See <b>catenation</b> and <b>substring</b>. If two non dynamic <b>char</b>(<i>n</i>) values (or <b>char</b> values) are catenated, the result is a <b>char</b>(<i>n</i>)value. If either are dynamic,  it is a <b>string</b> value. This implies that very long <b>char</b>(<i>n</i>) values can be created by catenating them together, for example to initialize a <b>char</b>(<i>n</i>) variable.</p>\n<p>\r\nA <b>char</b> value can be assigned (or passed to an non <b>var</b> parameter) with automatic conversion to a <b>char</b>(1) variable and vice versa. String values of length 1 can be assigned to <b>char</b> variables. Character (<b>char</b>) values can be assigned to string variables, yielding a string of length 1. String values of length <i>n</i> are assignable with automatic conversion to <b>char</b>(<i>n</i>) variables. Values of type <b>char</b>(<i>n</i>) can be assigned with automatic conversion to <b>string</b> variables.</p>\n<p>\r\nWhen comparing two <b>char</b>(<i>n</i>) values, as in s &gt; t, if both are non-dynamic and of the same length, they are compared without converting to strings. If either are dynamic, they are converted to strings and then compared.</p>\n<p>\r\n</p>",
      "text_content": " Explicit constants for the char(n) type use single quotes as in 'M4V1Y9', as opposed to explicit string constants which use double quotes, as in \"Nancy\". A single character single quoted character, such as 'A', is considered to have the type char instead of char(n), but since these two types can be assigned to each other and compared to each other, this fact has little consequence.\r\nThe type char(n) is generally more difficult to use than the string type, which is favored for most simple programs. The type char(n) has the advantage that it is efficient in terms of both space and time. In particular, it is represented as n bytes in the computer's memory. By contrast, the string type must use extra space (a trailing zero byte in current implementations) to represent the current length and allocates space for the maximum value it can hold.\r\nThe form of numberOfCharacters is one of:\r\n (a) expn % Integer value (b) * % Only in subprogram parameters\r\nThe first form determines n. If the expression is a run time value, the type is considered to be dynamic char(n). The value of n must be at least 1. The second form is used only for subprogram parameters and uses the length of the actual parameter. This too, is considered to be a dynamic char(n) type. Dynamic char(n) types can only be passed to char(*) parameters. Dynamic char(n) types have the same restrictions as dynamic arrays. This implies they cannot be assigned as a whole and cannot appear in record and union types.\r\nAn implementation may impose a limit, recommended to be at least 32767, on the length n.\r\nValues of the char(n) type can be assigned and they can be compared for both equality and for ordering, but only if they have the same length and they are not dynamic (i.e. the length must be known at compile time).\r\nValues of the char(n) type can be read and written by get and put statements.\r\nThe char(n) type is a nonscalar, which implies that its parameters are always passed by reference (by means of an implicit pointer).\r\nAs is true for the char type, all 256 possible values of an 8-bit byte are allowed for each character in char(n) type. There is no pattern left to be used for the \"initialized value\", so there is no uninitialized checking for char(n).\r\nIn general, you can freely intermix the values of the types char, char(n) and string. This means that catenation (+), comparisons, length and substrings can be applied to any of these types. See catenation and substring. If two non dynamic char(n) values (or char values) are catenated, the result is a char(n)value. If either are dynamic,  it is a string value. This implies that very long char(n) values can be created by catenating them together, for example to initialize a char(n) variable.\r\nA char value can be assigned (or passed to an non var parameter) with automatic conversion to a char(1) variable and vice versa. String values of length 1 can be assigned to char variables. Character (char) values can be assigned to string variables, yielding a string of length 1. String values of length n are assignable with automatic conversion to char(n) variables. Values of type char(n) can be assigned with automatic conversion to string variables.\r\nWhen comparing two char(n) values, as in s > t, if both are non-dynamic and of the same length, they are compared without converting to strings. If either are dynamic, they are converted to strings and then compared.\r\n",
      "mdown_content": "Explicit constants for the **char**(_n_) type use single quotes as in 'M4V1Y9', as opposed to explicit **string** constants which use double quotes, as in \"Nancy\". A single character single quoted character, such as 'A', is considered to have the type **char** instead of **char**(_n_), but since these two types can be assigned to each other and compared to each other, this fact has little consequence.\nThe type **char**(_n_) is generally more difficult to use than the **string** type, which is favored for most simple programs. The type **char**(_n_) has the advantage that it is efficient in terms of both space and time. In particular, it is represented as _n_ bytes in the computer's memory. By contrast, the **string** type must use extra space (a trailing zero byte in current implementations) to represent the current length and allocates space for the maximum value it can hold.\nThe form of _numberOfCharacters_ is one of:\n\n\n\n\nThe first form determines _n_. If the expression is a run time value, the type is considered to be _dynamic_ **char**(_n_). The value of _n_ must be at least 1. The second form is used only for subprogram parameters and uses the length of the actual parameter. This too, is considered to be a _dynamic_ **char**(_n_) type. Dynamic **char**(_n_) types can only be passed to **char**(*) parameters. Dynamic **char**(_n_) types have the same restrictions as dynamic arrays. This implies they cannot be assigned as a whole and cannot appear in record and union types.\nAn implementation may impose a limit, recommended to be at least 32767, on the length _n_.\nValues of the **char**(_n_) type can be assigned and they can be compared for both equality and for ordering, but only if they have the same length and they are not dynamic (i.e. the length must be known at compile time).\nValues of the **char**(_n_) type can be read and written by **get** and **put** statements.\nThe **char**(_n_) type is a nonscalar, which implies that its parameters are always passed by reference (by means of an implicit pointer).\nAs is true for the **char** type, all 256 possible values of an 8-bit byte are allowed for each character in **char**(_n_) type. There is no pattern left to be used for the \"initialized value\", so there is no uninitialized checking for **char**(_n_).\nIn general, you can freely intermix the values of the types **char**, **char**(_n_) and **string**. This means that catenation (+), comparisons, **length** and substrings can be applied to any of these types. See **catenation** and **substring**. If two non dynamic **char**(_n_) values (or **char** values) are catenated, the result is a **char**(_n_)value. If either are dynamic,  it is a **string** value. This implies that very long **char**(_n_) values can be created by catenating them together, for example to initialize a **char**(_n_) variable.\nA **char** value can be assigned (or passed to an non **var** parameter) with automatic conversion to a **char**(1) variable and vice versa. String values of length 1 can be assigned to **char** variables. Character (**char**) values can be assigned to string variables, yielding a string of length 1. String values of length _n_ are assignable with automatic conversion to **char**(_n_) variables. Values of type **char**(_n_) can be assigned with automatic conversion to **string** variables.\nWhen comparing two **char**(_n_) values, as in s > t, if both are non-dynamic and of the same length, they are compared without converting to strings. If either are dynamic, they are converted to strings and then compared."
    },
    {
      "title": "See also",
      "links": [
        "char",
        "string1"
      ],
      "raw_content": "the <b><a href=\"char.html\">char</a></b> type which is much like <b>char</b>(1). See also the <b><a href=\"string1.html\">string</a></b> type.<p>\r\n</p>",
      "text_content": " the char type which is much like char(1). See also the string type.\r\n",
      "mdown_content": "the **[char.html](char)** type which is much like **char**(1). See also the **[string1.html](string)** type."
    }
  ],
  "dependencies": [

  ]
}
