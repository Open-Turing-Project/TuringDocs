{
  "title": "import",
  "fileName": "import",
  "sections": [
    {
      "title": "Syntax",
      "raw_content": "An <i>importList</i> is:<p>\r\n</p>\n<table>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"8\"><font size=\"+1\"><b>import</b> [ <i>howImport</i> ] <i>importItem</i> </font></td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td width=\"40\">&nbsp;</td>\n<td width=\"40\">&nbsp;</td>\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"5\"><font size=\"+1\">{, [<i>howImport</i>] <i>importItem</i> }</font></td>\n</tr>\n</table>\n<p></p>",
      "text_content": "  An importList is:\r\n import [ howImport ] importItem     {, [howImport] importItem }",
      "mdown_content": "An _importList_ is:\n\n\n**import** [ _howImport_ ] _importItem_ \n{, [_howImport_] _importItem_ }\n\n"
    },
    {
      "title": "Description",
      "raw_content": "An <b>import</b> list is used to specify those items that a procedure, function, module, monitor, or a class uses from outside of itself. Note that a function or procedure is not allowed to have an import list and thus automatically imports whichever functions or procedures are used by the function or procedure. The compiler determines the list automatically by looking to see what items are actually used.<p>\r\n</p>",
      "text_content": " An import list is used to specify those items that a procedure, function, module, monitor, or a class uses from outside of itself. Note that a function or procedure is not allowed to have an import list and thus automatically imports whichever functions or procedures are used by the function or procedure. The compiler determines the list automatically by looking to see what items are actually used.\r\n",
      "mdown_content": "An **import** list is used to specify those items that a procedure, function, module, monitor, or a class uses from outside of itself. Note that a function or procedure is not allowed to have an import list and thus automatically imports whichever functions or procedures are used by the function or procedure. The compiler determines the list automatically by looking to see what items are actually used.\n"
    },
    {
      "title": "Example",
      "code": [
        "        type T : string\r\n        \r\n        module stack\r\n            import T\r\n            export push, pop\r\n            var top : int := 0\r\n            var contents : array 1..100 of T\r\n            procedure push  end push\r\n            procedure pop  end pop\r\n        end stack"
      ],
      "raw_content": "In this example, the type <i>T </i>is imported into the <i>stack </i><b>module</b> and used as the type that can be pushed onto or popped off the stack. Since no other items are imported, the only identifiers from outside of <i>stack </i>that can be used in it must be predefined, such as <b>sqrt</b>, or declared to be <b>pervasive</b>.<p>\r\n</p>",
      "text_content": " In this example, the type T is imported into the stack module and used as the type that can be pushed onto or popped off the stack. Since no other items are imported, the only identifiers from outside of stack that can be used in it must be predefined, such as sqrt, or declared to be pervasive.\r\n\r\n",
      "mdown_content": "In this example, the type _T_ is imported into the _stack_ **module** and used as the type that can be pushed onto or popped off the stack. Since no other items are imported, the only identifiers from outside of _stack_ that can be used in it must be predefined, such as **sqrt**, or declared to be **pervasive**.\n"
    },
    {
      "title": "Details",
      "code": [
        "        import ledger in \"newledg.t\"",
        "        import ( ledger in \"newledg.t\" )"
      ],
      "raw_content": "The <i>importItem </i>is one of<i>:</i><p>\r\n</p>\n<table>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td>(a) <i>id</i>\n</td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td>(b) <i>id </i><b>in</b><i> fileName</i>\n</td>\n</tr>\n</table>\n<p>\r\nThe second form is used in OOT when the list is the import list  for a separate <b>unit</b> (or the main program), and the imported item is in a file whose name is different from the item's name, for example:</p>\n<p>\r\n</p>\r\nThe <i>fileName</i> must be an explicit character string. See also <b>unit</b>.<p>\r\nParentheses are allowed around the items in an import lists, as in:</p>\n<p>\r\n</p>\r\nThere are various ways to import items, as determined by <i>howImport</i>. The form of <i>howImport</i> is one of:<p>\r\n</p>\n<table>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td>(a) <b>var</b>\n</td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td>(b) <b>const</b>\n</td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td>(c) <b>forward</b>\n</td>\n</tr>\n</table>\n<p>\r\nCommonly the <i>howImport </i>is omitted, which means the default access for the item is the same access as the item has. In other words, a read-write item that is imported without a <i>howImport</i> is imported read-write. A read-only symbol that is imported without a <i>howImport</i> is imported read-only.</p>\n<p>\r\nIf the <i>importItem </i>is <b>forward</b>, the import list is part of a <b>forward</b> procedure or function declaration and the imported item is itself necessarily a procedure or function. See <b>forward</b> declarations for details and an example.</p>\n<p>\r\nIf the <b>import</b> list of a <b>module</b>, <b>monitor</b> or <b>class</b> is omitted, the implementation assumes that the list is <b>import</b>( ), meaning that no items are imported. For example, a <b>module</b> must explicitly import any global identifiers that are not predefined or <b>pervasive</b>.</p>\n<p>\r\nCircular (recursive) imports are not allowed. For example, if unit <i>A</i> imports <i>B</i> then <i>B</i> cannot import <i>A</i>. However, circular usage of separately compiled units is possible by separating the units into interfaces and bodies and having the bodies import the interfaces. For example, if <i>C</i> is the parent class of <i>D</i>, <i>D</i> can import <i>C</i>, but not vice versa.</p>\n<p>\r\nIn an expansion (or implementation), the import list of the expansion augments the import list of the parent.</p>\n<p>\r\nAn overriding subprogram (in an expansion) ignores the import list of the target subprogram and uses its own import list.</p>\n<p>\r\nTuring initializes modules and monitors  in order of importation. Initialization begins with the main program, which first initializes its imports in the order given in its <b>import</b> list, and then initializes itself.</p>\n<p>\r\n</p>",
      "text_content": " The importItem is one of:\r\n (a) id (b) id in fileName\r\nThe second form is used in OOT when the list is the import list  for a separate unit (or the main program), and the imported item is in a file whose name is different from the item's name, for example:\r\n\r\nThe fileName must be an explicit character string. See also unit.\r\nParentheses are allowed around the items in an import lists, as in:\r\n\r\nThere are various ways to import items, as determined by howImport. The form of howImport is one of:\r\n (a) var (b) const (c) forward\r\nCommonly the howImport is omitted, which means the default access for the item is the same access as the item has. In other words, a read-write item that is imported without a howImport is imported read-write. A read-only symbol that is imported without a howImport is imported read-only.\r\nIf the importItem is forward, the import list is part of a forward procedure or function declaration and the imported item is itself necessarily a procedure or function. See forward declarations for details and an example.\r\nIf the import list of a module, monitor or class is omitted, the implementation assumes that the list is import( ), meaning that no items are imported. For example, a module must explicitly import any global identifiers that are not predefined or pervasive.\r\nCircular (recursive) imports are not allowed. For example, if unit A imports B then B cannot import A. However, circular usage of separately compiled units is possible by separating the units into interfaces and bodies and having the bodies import the interfaces. For example, if C is the parent class of D, D can import C, but not vice versa.\r\nIn an expansion (or implementation), the import list of the expansion augments the import list of the parent.\r\nAn overriding subprogram (in an expansion) ignores the import list of the target subprogram and uses its own import list.\r\nTuring initializes modules and monitors  in order of importation. Initialization begins with the main program, which first initializes its imports in the order given in its import list, and then initializes itself.\r\n",
      "mdown_content": "The _importItem_ is one of_:_\n\n\n(a) _id_\n(b) _id_ **in** _fileName_\n\n\nThe second form is used in OOT when the list is the import list  for a separate **unit** (or the main program), and the imported item is in a file whose name is different from the item's name, for example:\n\nThe _fileName_ must be an explicit character string. See also **unit**.\n\nParentheses are allowed around the items in an import lists, as in:\n\nThere are various ways to import items, as determined by _howImport_. The form of _howImport_ is one of:\n\n\n(a) **var**\n(b) **const**\n(c) **forward**\n\n\nCommonly the _howImport_ is omitted, which means the default access for the item is the same access as the item has. In other words, a read-write item that is imported without a _howImport_ is imported read-write. A read-only symbol that is imported without a _howImport_ is imported read-only.\n\nIf the _importItem_ is **forward**, the import list is part of a **forward** procedure or function declaration and the imported item is itself necessarily a procedure or function. See **forward** declarations for details and an example.\n\nIf the **import** list of a **module**, **monitor** or **class** is omitted, the implementation assumes that the list is **import**( ), meaning that no items are imported. For example, a **module** must explicitly import any global identifiers that are not predefined or **pervasive**.\n\nCircular (recursive) imports are not allowed. For example, if unit _A_ imports _B_ then _B_ cannot import _A_. However, circular usage of separately compiled units is possible by separating the units into interfaces and bodies and having the bodies import the interfaces. For example, if _C_ is the parent class of _D_, _D_ can import _C_, but not vice versa.\n\nIn an expansion (or implementation), the import list of the expansion augments the import list of the parent.\n\nAn overriding subprogram (in an expansion) ignores the import list of the target subprogram and uses its own import list.\n\nTuring initializes modules and monitors  in order of importation. Initialization begins with the main program, which first initializes its imports in the order given in its **import** list, and then initializes itself.\n"
    },
    {
      "title": "See also",
      "links": [
        "unit",
        "module",
        "monitor",
        "class",
        "export",
        "inherit",
        "implement",
        "implement_by"
      ],
      "raw_content": "<b><a href=\"unit.html\">unit</a></b>, <b><a href=\"module.html\">module</a></b>, <b><a href=\"monitor.html\">monitor</a></b> and <b><a href=\"class.html\">class</a></b>. See also <b><a href=\"export.html\">export</a></b> list, <b><a href=\"inherit.html\">inherit</a></b> clause, <b><a href=\"implement.html\">implement</a></b> clause and <b><a href=\"implement_by.html\">implement by</a></b> clause.<p>\r\n</p>",
      "text_content": " unit, module, monitor and class. See also export list, inherit clause, implement clause and implement by clause.\r\n",
      "mdown_content": "**[unit.html](unit)**, **[module.html](module)**, **[monitor.html](monitor)** and **[class.html](class)**. See also **[export.html](export)** list, **[inherit.html](inherit)** clause, **[implement.html](implement)** clause and **[implement_by.html](implement by)** clause.\n"
    }
  ],
  "dependencies": [

  ]
}
