{
  "title": "monitor",
  "fileName": "monitor",
  "sections": [
    {
      "title": "Syntax",
      "raw_content": "A <i>monitorDeclaration</i> is:<p>\r\n</p>\n<table>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"8\"><font size=\"+1\"><b>monitor</b> <i>id</i></font></td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"7\"><font size=\"+1\">[ <b>implement</b> <i>implementItem </i>]</font></td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"7\"><font size=\"+1\">[ <b>implement</b> <b>by</b> <i>implementByItem </i>]</font></td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"7\"><font size=\"+1\">[ <b>import</b> [ <b>var</b> ] <i>importItem</i></font></td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td width=\"40\">&nbsp;</td>\n<td width=\"40\">&nbsp;</td>\n<td width=\"40\">&nbsp;</td>\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"4\"><font size=\"+1\"><i> </i>{,<i> </i>[ <b>var</b> ]<i> importItem</i> } ]</font></td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"7\"><font size=\"+1\">[ <b>export</b> [ <i>howExport</i> ] <i>id </i>{,[<i>howExport</i> ]<i> id</i> }]</font></td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"7\"><font size=\"+1\"><i>statementsAndDeclarations</i></font></td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"8\"><font size=\"+1\"><b>end</b> <i>id</i></font></td>\n</tr>\n</table>\n<p></p>",
      "text_content": " A monitorDeclaration is:\r\n monitor id  [ implement implementItem ]  [ implement by implementByItem ]  [ import [ var ] importItem      {, [ var ] importItem } ]  [ export [ howExport ] id {,[howExport ] id }]  statementsAndDeclarations end id",
      "mdown_content": "A *monitorDeclaration* is:\n **monitor** *id*  [ **implement** *implementItem *]  [ **implement** **by** *implementByItem *]  [ **import** [ **var** ] *importItem*     * *{,* *[ **var** ]* importItem* } ]  [ **export** [ *howExport* ] *id *{,[*howExport* ]* id* }]  *statementsAndDeclarations* **end** *id*"
    },
    {
      "title": "Description",
      "raw_content": "A monitor is a special purpose module (see <b>module</b>) that is used with concurrent processes (see <b>process</b>). At most, one concurrent process (see <b>process</b>) can be active in a monitor at a time. This means that a process will be blocked if it calls a monitor that is already active. The process will not be allowed to proceed until the monitor is inactive. The monitor provides <i>mutually exclusive </i>access to the monitor's internal data.<p>\r\n</p>",
      "text_content": " A monitor is a special purpose module (see module) that is used with concurrent processes (see process). At most, one concurrent process (see process) can be active in a monitor at a time. This means that a process will be blocked if it calls a monitor that is already active. The process will not be allowed to proceed until the monitor is inactive. The monitor provides mutually exclusive access to the monitor's internal data.\r\n",
      "mdown_content": "A monitor is a special purpose module (see **module**) that is used with concurrent processes (see **process**). At most, one concurrent process (see **process**) can be active in a monitor at a time. This means that a process will be blocked if it calls a monitor that is already active. The process will not be allowed to proceed until the monitor is inactive. The monitor provides *mutually exclusive *access to the monitor's internal data."
    },
    {
      "title": "Example",
      "code": [
        "        monitor controller\r\n            export observe, report\r\n        \r\n            var counter : int := 0\r\n        \r\n            procedure observe\r\n                counter := counter + 1\r\n            end observe\r\n        \r\n            procedure report (var n : int )\r\n                n := counter\r\n                counter := 0\r\n            end report\r\n        end controller\r\n        process observer\r\n            loop\r\n                 observe one event \r\n                controller . observe\r\n            end loop\r\n        end observer\r\n        \r\n        process reporter\r\n            var n : int\r\n            loop\r\n                controller.report ( n )\r\n                 report n events \r\n            end loop\r\n        end reporter\r\n        \r\n        fork observer       % Activate the observer\r\n        fork reporter       % Activate the reporter"
      ],
      "raw_content": "This monitor controls access to the <i>count</i> variable so it can be updated by two processes (the <i>observer</i> and the <i>reporter</i>) without being corrupted by this concurrent access. Generally, it is not safe to have one process update a variable that other processes are simultaneously accessing. The <i>observer</i> process repeatedly increments the <i>counter</i> when it observes an event. The <i>reporter</i> process repeatedly writes out the number of events that have occurred since the last report, resetting the <i>counter</i> to zero.<p>\r\n</p>",
      "text_content": " This monitor controls access to the count variable so it can be updated by two processes (the observer and the reporter) without being corrupted by this concurrent access. Generally, it is not safe to have one process update a variable that other processes are simultaneously accessing. The observer process repeatedly increments the counter when it observes an event. The reporter process repeatedly writes out the number of events that have occurred since the last report, resetting the counter to zero.\r\n\r\n",
      "mdown_content": "This monitor controls access to the *count* variable so it can be updated by two processes (the *observer* and the *reporter*) without being corrupted by this concurrent access. Generally, it is not safe to have one process update a variable that other processes are simultaneously accessing. The *observer* process repeatedly increments the *counter* when it observes an event. The *reporter* process repeatedly writes out the number of events that have occurred since the last report, resetting the *counter* to zero."
    },
    {
      "title": "Details",
      "raw_content": "A <b>monitor</b> is essentially a module in which only one process can be active at a time. See <b>module</b> declarations for details about initialization. Initialization is the same for modules and monitors.<p>\r\nA monitor can contain <b>wait</b> statements (that put processes to sleep) and <b>signal</b> statements (that wake them up again). These statements operate on <b>condition</b> variables, which are essentially queues of sleeping processes.</p>\n<p>\r\nA class is essentially a template for creating individual modules (objects). See <b>class</b> for details. If the class declaration is preceded by the keyword <b>monitor</b>, the created modules are actually monitors. Monitor classes can only inherit (inherit from) other monitor classes.</p>\n<p>\r\nThe body of a monitor has the same form as that of a module, except that modules, monitors and processes cannot be declared inside monitors, and certain statements (<b>wait</b> and <b>signal</b>) are allowed in monitors.</p>\n<p>\r\n</p>",
      "text_content": " A monitor is essentially a module in which only one process can be active at a time. See module declarations for details about initialization. Initialization is the same for modules and monitors.\r\nA monitor can contain wait statements (that put processes to sleep) and signal statements (that wake them up again). These statements operate on condition variables, which are essentially queues of sleeping processes.\r\nA class is essentially a template for creating individual modules (objects). See class for details. If the class declaration is preceded by the keyword monitor, the created modules are actually monitors. Monitor classes can only inherit (inherit from) other monitor classes.\r\nThe body of a monitor has the same form as that of a module, except that modules, monitors and processes cannot be declared inside monitors, and certain statements (wait and signal) are allowed in monitors.\r\n",
      "mdown_content": "A **monitor** is essentially a module in which only one process can be active at a time. See **module** declarations for details about initialization. Initialization is the same for modules and monitors.\nA monitor can contain **wait** statements (that put processes to sleep) and **signal** statements (that wake them up again). These statements operate on **condition** variables, which are essentially queues of sleeping processes.\nA class is essentially a template for creating individual modules (objects). See **class** for details. If the class declaration is preceded by the keyword **monitor**, the created modules are actually monitors. Monitor classes can only inherit (inherit from) other monitor classes.\nThe body of a monitor has the same form as that of a module, except that modules, monitors and processes cannot be declared inside monitors, and certain statements (**wait** and **signal**) are allowed in monitors."
    },
    {
      "title": "Details",
      "code": [
        "        monitor id [ : compileTimeIntegerExpn ]\r\n            [ implement implementItem ]\r\n            [ implement by implementByItem ]\r\n            [ import [ var ] importItem {, [ var ] importItem } ]\r\n            [ export [ howExport ] id {, [ howExport ] id } ]\r\n            [ pre trueFalseExpn ]\r\n            statementsAndDeclarations\r\n            [ invariant trueFalseExpn ]\r\n            statementsAndDeclarations\r\n            [ post trueFalseExpn ]\r\n        end id"
      ],
      "raw_content": "The syntax of a <i>monitorDeclaration</i> presented above has been simplified by leaving out <b>pre</b>, <b>invariant</b> and <b>post</b> clauses. See <b>module</b> for an explanation of these extra features. There is also an optional <i>compilerTimeIntegerExpression</i> in the first line, which is explained below. The full syntax<i> </i>is:<p>\r\n</p>\r\nIf the optional <i>compileTimeIntegerExpression</i> is present, this is a <i>device monitor</i>. Its exclusive access is enforced by an implementation-dependent trick, such as executing it at a hardware priority level given by the expression. A device monitor is restricted from calling monitors (directly or indirectly). This restriction is imposed to eliminate the possibility of blocking a process with a non-zero hardware priority (as this would inadvertently allow multiple entry into a device monitor). It is the programmer's responsibility to meet this restriction; the compiler will not in general enforce the restriction. The current (1999) implementation ignores this <i>compileTimeIntegerExpression</i>.<p>\r\n</p>",
      "text_content": " The syntax of a monitorDeclaration presented above has been simplified by leaving out pre, invariant and post clauses. See module for an explanation of these extra features. There is also an optional compilerTimeIntegerExpression in the first line, which is explained below. The full syntax is:\r\n\r\nIf the optional compileTimeIntegerExpression is present, this is a device monitor. Its exclusive access is enforced by an implementation-dependent trick, such as executing it at a hardware priority level given by the expression. A device monitor is restricted from calling monitors (directly or indirectly). This restriction is imposed to eliminate the possibility of blocking a process with a non-zero hardware priority (as this would inadvertently allow multiple entry into a device monitor). It is the programmer's responsibility to meet this restriction; the compiler will not in general enforce the restriction. The current (1999) implementation ignores this compileTimeIntegerExpression.\r\n",
      "mdown_content": "The syntax of a *monitorDeclaration* presented above has been simplified by leaving out **pre**, **invariant** and **post** clauses. See **module** for an explanation of these extra features. There is also an optional *compilerTimeIntegerExpression* in the first line, which is explained below. The full syntax* *is:\nIf the optional *compileTimeIntegerExpression* is present, this is a *device monitor*. Its exclusive access is enforced by an implementation-dependent trick, such as executing it at a hardware priority level given by the expression. A device monitor is restricted from calling monitors (directly or indirectly). This restriction is imposed to eliminate the possibility of blocking a process with a non-zero hardware priority (as this would inadvertently allow multiple entry into a device monitor). It is the programmer's responsibility to meet this restriction; the compiler will not in general enforce the restriction. The current (1999) implementation ignores this *compileTimeIntegerExpression*."
    },
    {
      "title": "Details",
      "code": [
        "        procedure id [ : deviceSpecification ]"
      ],
      "raw_content": "An unexported parameterless procedure in a monitor can be specified to be an <i>interrupt handling procedure</i> by specifying a device in its header, using the form:<p>\r\n</p>\r\nThe <i>deviceSpecification</i> is a compile time natural number that designates, to the implementation, the class of interrupts that effectively call this procedure. Interrupt handling procedures cannot be called explicitly within the program.<p>\r\nThere are two restrictions that the programmer must follow when using interrupt handling procedures; these restrictions will not necessarily be enforced by the software. The first is that an interrupt handling procedure must not execute a <b>wait</b>, either directly or indirectly, by calling another procedure. The second is that the interrupt handling procedure must not directly or indirectly cause an exception, unless the exception will be caught by an exception handler that is activated directly or indirectly by the interrupt handling procedure.</p>\n<p>\r\n</p>",
      "text_content": " An unexported parameterless procedure in a monitor can be specified to be an interrupt handling procedure by specifying a device in its header, using the form:\r\n\r\nThe deviceSpecification is a compile time natural number that designates, to the implementation, the class of interrupts that effectively call this procedure. Interrupt handling procedures cannot be called explicitly within the program.\r\nThere are two restrictions that the programmer must follow when using interrupt handling procedures; these restrictions will not necessarily be enforced by the software. The first is that an interrupt handling procedure must not execute a wait, either directly or indirectly, by calling another procedure. The second is that the interrupt handling procedure must not directly or indirectly cause an exception, unless the exception will be caught by an exception handler that is activated directly or indirectly by the interrupt handling procedure.\r\n",
      "mdown_content": "An unexported parameterless procedure in a monitor can be specified to be an *interrupt handling procedure* by specifying a device in its header, using the form:\nThe *deviceSpecification* is a compile time natural number that designates, to the implementation, the class of interrupts that effectively call this procedure. Interrupt handling procedures cannot be called explicitly within the program.\nThere are two restrictions that the programmer must follow when using interrupt handling procedures; these restrictions will not necessarily be enforced by the software. The first is that an interrupt handling procedure must not execute a **wait**, either directly or indirectly, by calling another procedure. The second is that the interrupt handling procedure must not directly or indirectly cause an exception, unless the exception will be caught by an exception handler that is activated directly or indirectly by the interrupt handling procedure."
    },
    {
      "title": "Details",
      "raw_content": "Declarations of monitors within monitors are disallowed. This would be  redundant anyway, as only one process can be inside the outer monitor, so the inner monitor is guaranteed to be successful.<p>\r\nDeclarations of classes within monitors are also disallowed.</p>\n<p>\r\nAny subprogram declared within a subprogram is now allowed to be assigned to a subprogram variable, nor passed as a parametric subprogram.</p>\n<p>\r\n</p>",
      "text_content": " Declarations of monitors within monitors are disallowed. This would be  redundant anyway, as only one process can be inside the outer monitor, so the inner monitor is guaranteed to be successful.\r\nDeclarations of classes within monitors are also disallowed.\r\nAny subprogram declared within a subprogram is now allowed to be assigned to a subprogram variable, nor passed as a parametric subprogram.\r\n",
      "mdown_content": "Declarations of monitors within monitors are disallowed. This would be  redundant anyway, as only one process can be inside the outer monitor, so the inner monitor is guaranteed to be successful.\nDeclarations of classes within monitors are also disallowed.\nAny subprogram declared within a subprogram is now allowed to be assigned to a subprogram variable, nor passed as a parametric subprogram."
    },
    {
      "title": "See also",
      "links": [
        "unit",
        "module",
        "class",
        "export",
        "import",
        "implement",
        "implement_by",
        "deferred"
      ],
      "raw_content": "<b><a href=\"unit.html\">unit</a></b>, <b><a href=\"module.html\">module</a></b> and <b><a href=\"class.html\">class</a></b>. See also <b><a href=\"export.html\">export</a></b> list, <b><a href=\"import.html\">import</a></b> list, <b><a href=\"implement.html\">implement</a></b> list, <b><a href=\"implement_by.html\">implement by</a></b> list and <b><a href=\"deferred.html\">deferred</a></b> subprogram.<p>\r\n</p>",
      "text_content": " unit, module and class. See also export list, import list, implement list, implement by list and deferred subprogram.\r\n",
      "mdown_content": "**[unit.html](unit)**, **[module.html](module)** and **[class.html](class)**. See also **[export.html](export)** list, **[import.html](import)** list, **[implement.html](implement)** list, **[implement_by.html](implement by)** list and **[deferred.html](deferred)** subprogram."
    }
  ],
  "dependencies": [

  ]
}
