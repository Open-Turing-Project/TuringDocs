{
  "title": "class",
  "fileName": "class",
  "sections": [
    {
      "title": "Syntax",
      "raw_content": "A classDeclaration is:<p>\r\n</p>\n<table>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"8\"><font size=\"+1\">[ <b>monitor</b> ]</font></td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"8\"><font size=\"+1\"><b>class</b> <i>id</i></font></td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"7\"><font size=\"+1\">[ <b>inherit</b> <i>inheritItem </i>]</font></td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"7\"><font size=\"+1\">[ <b>implement</b> <i>implementItem </i>]</font></td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"7\"><font size=\"+1\">[ <b>implement</b> <b>by</b> <i>implementByItem </i>]</font></td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"7\"><font size=\"+1\">[ <b>import</b> [ <b>var</b> ] <i>importItem </i>{,<i> </i>[ <b>var</b> ]<i> importItem</i> } ]</font></td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"7\"><font size=\"+1\">[ <b>export</b> [ <i>howExport</i> ] <i>id </i>{,<i> </i>[ <i>howExport</i> ]<i> id</i> } ]</font></td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"7\"><font size=\"+1\"><i>statementsAndDeclarations</i></font></td>\n</tr>\n<tr valign=\"top\">\n<td width=\"40\">&nbsp;</td>\n<td colspan=\"8\"><font size=\"+1\"><b>end</b> <i>id</i></font></td>\n</tr>\n</table>\n<p></p>",
      "text_content": " A classDeclaration is:\r\n [ monitor ] class id  [ inherit inheritItem ]  [ implement implementItem ]  [ implement by implementByItem ]  [ import [ var ] importItem {, [ var ] importItem } ]  [ export [ howExport ] id {, [ howExport ] id } ]  statementsAndDeclarations end id",
      "mdown_content": "A classDeclaration is:\n\n[ **monitor** ]\n**class** _id_\n[ **inherit** _inheritItem _]\n[ **implement** _implementItem _]\n[ **implement** **by** _implementByItem _]\n[ **import** [ **var** ] _importItem _{,_ _[ **var** ]_ importItem_ } ]\n[ **export** [ _howExport_ ] _id _{,_ _[ _howExport_ ]_ id_ } ]\n_statementsAndDeclarations_\n**end** _id_\n"
    },
    {
      "title": "Description",
      "raw_content": "A class declaration defines a template for a package of variables, constants, types, subprograms, etc. The name of the class (<i>id</i>) is given in two places, just after <b>class</b> and just after <b>end</b>. Items declared inside the class can be accessed outside of the class only if they are exported. Items from outside the class that are to be used in the class, need to be imported (unless they are predefined or pervasive). Instances (objects) of a class are created using the <b>new</b> statement. Each object is essentially a module located by a pointer.<p>\r\n</p>",
      "text_content": " A class declaration defines a template for a package of variables, constants, types, subprograms, etc. The name of the class (id) is given in two places, just after class and just after end. Items declared inside the class can be accessed outside of the class only if they are exported. Items from outside the class that are to be used in the class, need to be imported (unless they are predefined or pervasive). Instances (objects) of a class are created using the new statement. Each object is essentially a module located by a pointer.\r\n",
      "mdown_content": "A class declaration defines a template for a package of variables, constants, types, subprograms, etc. The name of the class (_id_) is given in two places, just after **class** and just after **end**. Items declared inside the class can be accessed outside of the class only if they are exported. Items from outside the class that are to be used in the class, need to be imported (unless they are predefined or pervasive). Instances (objects) of a class are created using the **new** statement. Each object is essentially a module located by a pointer."
    },
    {
      "title": "Example",
      "code": [
        "        class stackClass    % Template for creating individual stacks\r\n            export push, pop\r\n        \r\n            var top : int := 0\r\n            var contents : array 1 .. 100 of string\r\n        \r\n            procedure push (s : string)\r\n                top := top + 1\r\n                contents (top) := s\r\n            end push\r\n        \r\n            procedure pop (var s : string)\r\n                s := contents (top)\r\n                top := top - 1\r\n            end pop\r\n        end stackClass\r\n        \r\n        var p: pointer to stackClass    % Short form: var p: ^stackClass\r\n        new stackClass, p           % Short form: new p\r\n        p -> push (\"Harvey\")\r\n        var name : string\r\n        p -> pop (name)         % This sets name to be Harvey"
      ],
      "raw_content": "This class is a template for creating objects, each of which is a stack of strings. (See the <b>module</b> description for the corresponding module that implements a single stack of strings.)<p>\r\n</p>",
      "text_content": " This class is a template for creating objects, each of which is a stack of strings. (See the module description for the corresponding module that implements a single stack of strings.)\r\n\r\n    ",
      "mdown_content": "This class is a template for creating objects, each of which is a stack of strings. (See the **module** description for the corresponding module that implements a single stack of strings.)"
    },
    {
      "title": "Execute",
      "executables": [
        {
          "buttontext": "Launch Example Program",
          "name": "class Example",
          "file": "class.t"
        }
      ]
    },
    {
      "title": "Details",
      "code": [
        "        var s : stack       % Not legal!"
      ],
      "raw_content": "The <b>new</b> statement is used to create objects of a class. Many instances of a class can exist at a given time, each located by a pointer. The <b>free</b> statement is used to destroy objects that are no longer of use. Turing does not support <i>garbage collection</i> (automatic recovery of space belonging to inaccessible objects).<p>\r\nSee <b>modules</b> for a discussion of importing, exporting and related concepts. When an object is created by <b>new</b>, its initialization code is executed. In this example, the object's <i>top</i> variable<i> </i>is set to 0. As is true in modules, an exported subprogram of an object's class cannot be called until the object is completely initialized.</p>\n<p>\r\nYou are not allowed to create variables of a class, as in:</p>\n<p>\r\n</p>\r\nIf the <b>monitor</b> keyword is present (just before <b>class</b>), the objects are monitors. This means that only one process at a time can be active in the object. See <b>monitor</b> and <b>process</b>.<p>\r\nInherit lists are used to specify inheritance. See <b>inherit</b> list. Implement and implement-by lists provide a special kind of expansion which supports the separation of an interface from its implementation. See <b>implement</b> list and <b>implement-by</b> list. A class cannot contain both an inherit and an implement list.</p>\n<p>\r\nClass declarations can be nested inside modules and monitors but cannot be nested inside other classes or inside procedures or functions. A class must not contain a <b>bind</b> as one of its (outermost) declarations. A <b>return</b> statement cannot be used as one of the (outermost) statements in a class.</p>\n<p>\r\nA class cannot export variables (or run time constants) as <b>unqualified</b> (because each object has a distinct set of variables).</p>\n<p>\r\nThe syntax of a <i>classDeclaration</i> presented above has been simplified by leaving out <b>pre</b>, <b>invariant</b> and <b>post</b> clauses. The full syntax<i> </i>which supports <b>pre</b>, <b>invariant</b> and <b>post</b> is the same as that for modules. The initialization of classes is the same as that for modules. See <b>module</b>.</p>\n<p>\r\n</p>",
      "text_content": " The new statement is used to create objects of a class. Many instances of a class can exist at a given time, each located by a pointer. The free statement is used to destroy objects that are no longer of use. Turing does not support garbage collection (automatic recovery of space belonging to inaccessible objects).\r\nSee modules for a discussion of importing, exporting and related concepts. When an object is created by new, its initialization code is executed. In this example, the object's top variable is set to 0. As is true in modules, an exported subprogram of an object's class cannot be called until the object is completely initialized.\r\nYou are not allowed to create variables of a class, as in:\r\n\r\nIf the monitor keyword is present (just before class), the objects are monitors. This means that only one process at a time can be active in the object. See monitor and process.\r\nInherit lists are used to specify inheritance. See inherit list. Implement and implement-by lists provide a special kind of expansion which supports the separation of an interface from its implementation. See implement list and implement-by list. A class cannot contain both an inherit and an implement list.\r\nClass declarations can be nested inside modules and monitors but cannot be nested inside other classes or inside procedures or functions. A class must not contain a bind as one of its (outermost) declarations. A return statement cannot be used as one of the (outermost) statements in a class.\r\nA class cannot export variables (or run time constants) as unqualified (because each object has a distinct set of variables).\r\nThe syntax of a classDeclaration presented above has been simplified by leaving out pre, invariant and post clauses. The full syntax which supports pre, invariant and post is the same as that for modules. The initialization of classes is the same as that for modules. See module.\r\n",
      "mdown_content": "The **new** statement is used to create objects of a class. Many instances of a class can exist at a given time, each located by a pointer. The **free** statement is used to destroy objects that are no longer of use. Turing does not support _garbage collection_ (automatic recovery of space belonging to inaccessible objects).\nSee **modules** for a discussion of importing, exporting and related concepts. When an object is created by **new**, its initialization code is executed. In this example, the object's _top_ variable_ _is set to 0. As is true in modules, an exported subprogram of an object's class cannot be called until the object is completely initialized.\nYou are not allowed to create variables of a class, as in:\nIf the **monitor** keyword is present (just before **class**), the objects are monitors. This means that only one process at a time can be active in the object. See **monitor** and **process**.\nInherit lists are used to specify inheritance. See **inherit** list. Implement and implement-by lists provide a special kind of expansion which supports the separation of an interface from its implementation. See **implement** list and **implement-by** list. A class cannot contain both an inherit and an implement list.\nClass declarations can be nested inside modules and monitors but cannot be nested inside other classes or inside procedures or functions. A class must not contain a **bind** as one of its (outermost) declarations. A **return** statement cannot be used as one of the (outermost) statements in a class.\nA class cannot export variables (or run time constants) as **unqualified** (because each object has a distinct set of variables).\nThe syntax of a _classDeclaration_ presented above has been simplified by leaving out **pre**, **invariant** and **post** clauses. The full syntax_ _which supports **pre**, **invariant** and **post** is the same as that for modules. The initialization of classes is the same as that for modules. See **module**."
    },
    {
      "title": "Example",
      "code": [
        "        class File\r\n            export open, close, read, write\r\n            deferred procedure open ( parameters for open )\r\n            deferred procedure close ( parameters for close )\r\n            deferred procedure read ( parameters for read )\r\n            deferred procedure write ( parameters for write )\r\n        end File",
        "        class TextFile\r\n            inherit File\r\n            var internalTextFileData :\r\n                 internal data for text files \r\n        \r\n            body procedure open\r\n                 body for open for text files \r\n            end open\r\n        \r\n             bodies for close, read and write procedures for text files\r\n        end TextFile",
        "        var textFilePtr : ^ TextFile\r\n                        % Pointer will locate a text file object\r\n        new textFilePtr     % Create a text file object\r\n        \r\n        textFilePtr -> read ( actual parameters )  % Read text file",
        "        class Device\r\n            inherit File\r\n            export ioCtl\r\n            deferred procedure ioCtl ( parameters for ioCtl )\r\n        end Device",
        "        class Disk\r\n            inherit Device\r\n            var internalDiskFileData :  internal data for disk files\r\n        \r\n            body procedure open\r\n                 body for open \r\n            end open\r\n        \r\n             bodies for close, read, write and ioCtl procedures for disk \r\n        end Disk",
        "        var filePtr : ^ File",
        "        filePtr := textFilePtr",
        "        filePtr -> read ( actual parameters )"
      ],
      "images": [
        "class01.gif"
      ],
      "raw_content": "We will give an example in which a subprogram in one class overrides the corresponding subprogram in a class that is being inherited. The example is based on a program that implements a file system inside an operating system. All files have <i>open</i>,<i> close</i>,<i> read </i>and <i>write</i> operations. Some files, called <i>Device</i> files, also have an operation called <i>ioCtl</i> (input/output control). The kind of file determines the implementation method. Here is the expansion (inheritance) hierarchy among the classes of files.<p>\r\n</p>\n<p>\r\n\r\n</p>\n<center></center>\r\nThe class called <i>File </i>gives the interface to all possible kinds of files. The <i>TextFile </i>class implements files that are text (ASCII characters). The <i>Device</i> class gives the interface to all files that have the <i>ioCtl</i> operation in addition to <i>open</i>,<i> close</i>,<i> read </i>and <i>write</i>. The <i>Tape</i> and <i>Disk</i> classes implement files that are actually physical tapes or disks. Here is the declaration of the <i>File</i> class:<p>\r\n</p>\r\nThe <i>TextFile</i> class implements the <i>File</i> interface by giving variables declarations and procedure bodies for ASCII files:<p>\r\n</p>\r\nObjects to represent individual text files are created using the <b>new</b> statement:<p>\r\n</p>\r\nThe <i>Device </i>class adds the <i>ioCtl </i>procedure to the <i>File</i> interface.<p>\r\n</p>\r\nThe <i>Disk </i>class provides data and procedures to implement a file that is actually a disk<i> </i>(the <i>Tape</i> class is analogous):<p>\r\n</p>\r\nA pointer that can locate any kind of <i>File</i> object is declared this way:<p>\r\n</p>\r\nThis may locate, for example, a <i>TextFile</i>:<p>\r\n</p>\r\nThis assignment is allowed because <i>filePtr'</i>s corresponding class (<i>File</i>) is an ancestor of <i>textFilePtr'</i>s corresponding class (<i>TextFile</i>). It is guaranteed that the object now located by <i>filePtr</i> supports a version of all the operations of a <i>File</i> (<i>open</i>, <i>close</i>, <i>read</i> and <i>write</i>).<p>\r\nWhen we call a procedure in the object located by <i>filePtr</i>, the actual procedure called will depend upon the object:</p>\n<p>\r\n</p>\r\nFor example, if <i>filePtr</i> currently locates a <i>Disk</i> file, this will call the <i>read</i> procedure from the <i>Disk</i> class. This is an example of <i>dynamic</i> <i>binding</i> in which  the version of <i>read </i>to be used is selected at run time and this choice is based on the object located by <i>filePtr</i>. This is called <i>polymorphism</i>, because <i>File</i> objects can have more than one form.<p>\r\n</p>",
      "text_content": " We will give an example in which a subprogram in one class overrides the corresponding subprogram in a class that is being inherited. The example is based on a program that implements a file system inside an operating system. All files have open, close, read and write operations. Some files, called Device files, also have an operation called ioCtl (input/output control). The kind of file determines the implementation method. Here is the expansion (inheritance) hierarchy among the classes of files.\r\n\r\n\r\n\r\nThe class called File gives the interface to all possible kinds of files. The TextFile class implements files that are text (ASCII characters). The Device class gives the interface to all files that have the ioCtl operation in addition to open, close, read and write. The Tape and Disk classes implement files that are actually physical tapes or disks. Here is the declaration of the File class:\r\n\r\nThe TextFile class implements the File interface by giving variables declarations and procedure bodies for ASCII files:\r\n\r\nObjects to represent individual text files are created using the new statement:\r\n\r\nThe Device class adds the ioCtl procedure to the File interface.\r\n\r\nThe Disk class provides data and procedures to implement a file that is actually a disk (the Tape class is analogous):\r\n\r\nA pointer that can locate any kind of File object is declared this way:\r\n\r\nThis may locate, for example, a TextFile:\r\n\r\nThis assignment is allowed because filePtr's corresponding class (File) is an ancestor of textFilePtr's corresponding class (TextFile). It is guaranteed that the object now located by filePtr supports a version of all the operations of a File (open, close, read and write).\r\nWhen we call a procedure in the object located by filePtr, the actual procedure called will depend upon the object:\r\n\r\nFor example, if filePtr currently locates a Disk file, this will call the read procedure from the Disk class. This is an example of dynamic binding in which  the version of read to be used is selected at run time and this choice is based on the object located by filePtr. This is called polymorphism, because File objects can have more than one form.\r\n",
      "mdown_content": "We will give an example in which a subprogram in one class overrides the corresponding subprogram in a class that is being inherited. The example is based on a program that implements a file system inside an operating system. All files have _open_,_ close_,_ read _and _write_ operations. Some files, called _Device_ files, also have an operation called _ioCtl_ (input/output control). The kind of file determines the implementation method. Here is the expansion (inheritance) hierarchy among the classes of files.\n\nThe class called _File _gives the interface to all possible kinds of files. The _TextFile _class implements files that are text (ASCII characters). The _Device_ class gives the interface to all files that have the _ioCtl_ operation in addition to _open_,_ close_,_ read _and _write_. The _Tape_ and _Disk_ classes implement files that are actually physical tapes or disks. Here is the declaration of the _File_ class:\nThe _TextFile_ class implements the _File_ interface by giving variables declarations and procedure bodies for ASCII files:\nObjects to represent individual text files are created using the **new** statement:\nThe _Device _class adds the _ioCtl _procedure to the _File_ interface.\nThe _Disk _class provides data and procedures to implement a file that is actually a disk_ _(the _Tape_ class is analogous):\nA pointer that can locate any kind of _File_ object is declared this way:\nThis may locate, for example, a _TextFile_:\nThis assignment is allowed because _filePtr'_s corresponding class (_File_) is an ancestor of _textFilePtr'_s corresponding class (_TextFile_). It is guaranteed that the object now located by _filePtr_ supports a version of all the operations of a _File_ (_open_, _close_, _read_ and _write_).\nWhen we call a procedure in the object located by _filePtr_, the actual procedure called will depend upon the object:\nFor example, if _filePtr_ currently locates a _Disk_ file, this will call the _read_ procedure from the _Disk_ class. This is an example of _dynamic_ _binding_ in which  the version of _read _to be used is selected at run time and this choice is based on the object located by _filePtr_. This is called _polymorphism_, because _File_ objects can have more than one form."
    },
    {
      "title": "Example",
      "code": [
        "        class C\r\n            export f, g\r\n        \r\n            procedure f\r\n                put \"C's f\"\r\n            end f\r\n        \r\n            procedure g\r\n                put \"C's g\"\r\n            end g\r\n        end C\r\n        \r\n        class D\r\n            inherit C           % Inherit f and g\r\n        \r\n            body procedure g    % Overrides g in C\r\n                put \"*** D's g ***\"\r\n            end g\r\n        \r\n            procedure h\r\n                put \"*** D's h ***\"\r\n            end h\r\n        end D\r\n\r\n        var p : pointer to C    % p can point to any descendant of C\r\n        new D, p        % p locates an object of class D\r\n        p -> f          % Outputs \"C's f\"\r\n        p -> g          % Outputs \"*** D's g ***\"\r\n        p -> h          % Causes error \"'h' is not in export list of 'C'\""
      ],
      "raw_content": "As another example, consider class <i>C</i>, which contains headers and bodies for functions <i>f</i> and <i>g</i>. <i>C</i> exports functions <i>f</i> and <i>g</i>. There is also a class <i>D</i>, which inherits from <i>C</i>. Class <i>D</i> contains a body that overrides the body for <i>g</i>. <i>D</i> also contains a header and body for function <i>h</i>. <i>D</i> exports function <i>h</i>.<p>\r\nPointer <i>p</i> has been declared to locate an object of class <i>C</i>, but at runtime <i>p</i> locates an object of class <i>D</i>. When p is used to call <i>f</i>, by means of <i>p</i>-&gt;<i>f</i>, the body of <i>f</i>, which appears in <i>C</i>, is invoked. When p is used to call <i>g</i>, by means of <i>p</i>-&gt;<i>g</i>, <i>g</i>'s overriding body in <i>D</i> is invoked. Any attempt to use <i>p</i> to call <i>h</i> is illegal because <i>p</i> can only be used to call functions that are exported from <i>C</i>.</p>\n<p>\r\n</p>",
      "text_content": " As another example, consider class C, which contains headers and bodies for functions f and g. C exports functions f and g. There is also a class D, which inherits from C. Class D contains a body that overrides the body for g. D also contains a header and body for function h. D exports function h.\r\nPointer p has been declared to locate an object of class C, but at runtime p locates an object of class D. When p is used to call f, by means of p->f, the body of f, which appears in C, is invoked. When p is used to call g, by means of p->g, g's overriding body in D is invoked. Any attempt to use p to call h is illegal because p can only be used to call functions that are exported from C.\r\n\r\n    ",
      "mdown_content": "As another example, consider class _C_, which contains headers and bodies for functions _f_ and _g_. _C_ exports functions _f_ and _g_. There is also a class _D_, which inherits from _C_. Class _D_ contains a body that overrides the body for _g_. _D_ also contains a header and body for function _h_. _D_ exports function _h_.\nPointer _p_ has been declared to locate an object of class _C_, but at runtime _p_ locates an object of class _D_. When p is used to call _f_, by means of _p_->_f_, the body of _f_, which appears in _C_, is invoked. When p is used to call _g_, by means of _p_->_g_, _g_'s overriding body in _D_ is invoked. Any attempt to use _p_ to call _h_ is illegal because _p_ can only be used to call functions that are exported from _C_."
    },
    {
      "title": "Execute",
      "executables": [
        {
          "buttontext": "Launch Example Program",
          "name": "class Example",
          "file": "class2.t"
        }
      ]
    },
    {
      "title": "See also",
      "links": [
        "module",
        "monitor",
        "unit",
        "import",
        "export",
        "implement",
        "implement_by",
        "inherit",
        "deferred",
        "anyclass",
        "objectclass"
      ],
      "raw_content": "<b><a href=\"module.html\">module</a></b>, <b><a href=\"monitor.html\">monitor</a></b> and <b><a href=\"unit.html\">unit</a></b>. See also <b><a href=\"import.html\">import</a></b> list, <b><a href=\"export.html\">export</a></b> list, <b><a href=\"implement.html\">implement</a></b> list, <b><a href=\"implement_by.html\">implement by</a></b> list, and <b><a href=\"inherit.html\">inherit</a></b> list. See also <b><a href=\"deferred.html\">deferred</a></b> subprogram. See also <b><a href=\"anyclass.html\">anyclass</a></b> and <b><a href=\"objectclass.html\">objectclass</a></b>.<p>\r\n</p>",
      "text_content": " module, monitor and unit. See also import list, export list, implement list, implement by list, and inherit list. See also deferred subprogram. See also anyclass and objectclass.\r\n",
      "mdown_content": "**[module.html](module)**, **[monitor.html](monitor)** and **[unit.html](unit)**. See also **[import.html](import)** list, **[export.html](export)** list, **[implement.html](implement)** list, **[implement_by.html](implement by)** list, and **[inherit.html](inherit)** list. See also **[deferred.html](deferred)** subprogram. See also **[anyclass.html](anyclass)** and **[objectclass.html](objectclass)**."
    }
  ],
  "dependencies": [
    "class01.gif"
  ]
}
